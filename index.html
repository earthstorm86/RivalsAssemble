<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Marvel Rivals Roll‑A‑Roller</title>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <div class="logo"><img src="images/logo-small.png" alt="Rivals Assemble  " width="237" height="177"></div>
  <div class="main">
    <section class="panel player-panel"><ul id="playerList" class="player-list"></ul></section>
    <section class="panel options-panel">
      <button id="rollAllBtn"><i class="fas fa-dice"></i> Roll All</button>
      <button id="copyPlainTextBtn"><i class="fas fa-clipboard"></i> Copy to clipboard</button>
      <button id="darkBtn">Dark Mode</button>
      <div class="role-options-section">
        <h3>Minimums</h3>
        <div class="min-inputs-grid">
          <div class="option-group">
            <label for="vanguardMin">Vanguard</label>
            <button class="min-adjust-btn" data-direction="decrement">-</button>
            <input type="number" id="vanguardMin" value="1" min="0" max="6">
            <button class="min-adjust-btn" data-direction="increment">+</button>
          </div>
          <div class="option-group">
            <label for="duellistMin">Duellist</label>
            <button class="min-adjust-btn" data-direction="decrement">-</button>
            <input type="number" id="duellistMin" value="2" min="0" max="6">
            <button class="min-adjust-btn" data-direction="increment">+</button>
          </div>
          <div class="option-group">
            <label for="strategistMin">Strategist</label>
            <button class="min-adjust-btn" data-direction="decrement">-</button>
            <input type="number" id="strategistMin" value="2" min="0" max="6">
            <button class="min-adjust-btn" data-direction="increment">+</button>
          </div>
          <div class="option-group">
            <label for="flexMin">Flex</label>
            <button class="min-adjust-btn" data-direction="decrement">-</button>
            <input type="number" id="flexMin" value="0" min="0" max="6">
            <button class="min-adjust-btn" data-direction="increment">+</button>
          </div>
          <div id="minimumsWarning" class="warning-message"></div>
        </div>
        <label id="lblAutoSort"><input type="checkbox" id="autoSortCB" checked>Auto Sort Roles</label>
        <label id="lblRotateRoles"><input type="checkbox" id="rotateRolesCB" checked>Rotate Roles on Reroll</label>      </div>
    </section>
  </div>
<script>
const ANIMATE_ROLL_ALL_SORT = true; // Config option for animating sort on Roll All
let HEROES_BY_ROLE = {}; // Initialize as empty object

const ROLE_OVERLAY_CLASSES = [
  'role-overlay-strategist',
  'role-overlay-vanguard',
  'role-overlay-duellist',
  'role-overlay-flex'
];

async function loadHeroes() {
  try {
    const response = await fetch('data/heroes.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    HEROES_BY_ROLE = await response.json();
    console.log('Heroes loaded:', HEROES_BY_ROLE);
  } catch (error) {
    console.error('Could not load heroes:', error);
    // Optionally, set some default/empty hero lists or alert the user
    HEROES_BY_ROLE = {
      "Strategist": ["Error loading heroes"],
      "Vanguard": ["Error loading heroes"],
      "Duellist": ["Error loading heroes"]
    };
  }
}

const MIN_PLAYERS=2,MAX_PLAYERS=6;
const ICONS={vanguard:'images/VanguardIcon.png',duellist:'images/DuellistIcon.png',strategist:'images/StrategistIcon.png',flex:'images/FlexIcon.png'};
const BASE_ROLES=['vanguard','duellist','strategist'];
const list=document.getElementById('playerList');
const rollAllBtn=document.getElementById('rollAllBtn');
const darkBtn=document.getElementById('darkBtn');
const vanguardMinInput = document.getElementById('vanguardMin');
const duellistMinInput = document.getElementById('duellistMin');
const strategistMinInput = document.getElementById('strategistMin');
const flexMinInput = document.getElementById('flexMin');
const autoSortCB = document.getElementById('autoSortCB');
const rotateRolesCB = document.getElementById('rotateRolesCB');
const rng=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=rng(0,i);[a[i],a[j]]=[a[j],a[i]];}return a;};
const flexChance=()=>Math.random()<0.05;

function addPlayer(){if(list.children.length>=MAX_PLAYERS)return;const li=document.createElement('li');li.className='player-item';li.dataset.active = 'false'; // Initially inactive
li.innerHTML=`
  <button class="remove" title="Remove">×</button>
  <div class="player-name-wrapper">
    <input class="player-name" type="text" placeholder="Name">
    <button class="player-name-dropdown-arrow" title="Show saved names">▼</button>
    <div class="player-name-dropdown-list"></div>
  </div>
  <div class="role-info">
    <img class="role-icon" src="">
    <span class="role-name">No Role</span>
    <span class="suggested-hero"></span>
  </div>
  <button class="roll" title="Roll">
    <svg viewBox="0 0 24 24" width="1em" height="1em">
      <!-- Background rectangle - set fill to black -->
      <rect x="3" y="3" width="18" height="18" rx="3" ry="3" fill="black"/>
      <!-- Dots (positioned for faces 1-6) -->
      <!-- Center dot (for 1, 3, 5) -->
      <circle id="dot-center" cx="12" cy="12" r="2" fill="black"/>
      <!-- Top-left and Bottom-right dots (for 2, 3, 4, 5, 6) -->
      <circle id="dot-tl" cx="7" cy="7" r="2" fill="black"/>
      <circle id="dot-br" cx="17" cy="17" r="2" fill="black"/>
      <!-- Top-right and Bottom-left dots (for 4, 5, 6) -->
      <circle id="dot-tr" cx="17" cy="7" r="2" fill="black"/>
      <circle id="dot-bl" cx="7" cy="17" r="2" fill="black"/>
      <!-- Middle-left and Middle-right dots (for 6) -->
      <circle id="dot-mid-l" cx="7" cy="12" r="2" fill="black"/>
      <circle id="dot-mid-r" cx="17" cy="12" r="2" fill="black"/>
    </svg>
  </button>
`;li.dataset.lastRole='';li.dataset.streak='0';
const playerNameInput = li.querySelector('.player-name');
const dropdownArrow = li.querySelector('.player-name-dropdown-arrow');
const rollButton = li.querySelector('.roll'); // Get roll button

rollButton.disabled = true; // Disable roll button initially

li.querySelector('.remove').addEventListener('click',()=>{li.remove();updateUI();updateQuickPopButtons();updateAllPlayerStates();});
rollButton.addEventListener('click',()=>singleRoll(li));
playerNameInput.addEventListener('input', ()=>{
  updateQuickPopButtons();
  updateAllPlayerStates();
});
dropdownArrow.addEventListener('click', (e) => {
  e.stopPropagation(); 
  toggleNameDropdown(playerNameInput, dropdownArrow);
});

list.append(li);updateUI();updateQuickPopButtons();updateAllPlayerStates();}

// --- Functions for Name Dropdown (moved to global scope) ---
function toggleNameDropdown(inputElement, arrowButton) {
  const wrapper = inputElement.closest('.player-name-wrapper');
  const dropdownList = wrapper.querySelector('.player-name-dropdown-list');
  const isOpen = dropdownList.classList.toggle('open');
  if (isOpen) {
    renderNameDropdownList(inputElement, dropdownList);
  }
}

function renderNameDropdownList(inputElement, dropdownListContainer) {
  const currentInputValue = inputElement.value.trim();
  const allNames = getQuickNames();
  const namesToShow = allNames.filter(name => name.toLowerCase() !== currentInputValue.toLowerCase());

  dropdownListContainer.innerHTML = ''; // Clear previous items

  if (namesToShow.length === 0) {
    const noNamesItem = document.createElement('div');
    noNamesItem.textContent = 'No other saved names';
    noNamesItem.style.padding = '0.6rem 0.8rem';
    noNamesItem.style.color = '#888';
    dropdownListContainer.appendChild(noNamesItem);
    return;
  }

  namesToShow.forEach(name => {
    const item = document.createElement('div');
    item.className = 'player-name-dropdown-item';
    item.textContent = name;
    item.addEventListener('click', () => {
      inputElement.value = name;
      dropdownListContainer.classList.remove('open');
      inputElement.dispatchEvent(new Event('input', { bubbles: true })); 
      const playerItemLi = inputElement.closest('.player-item'); // Get the li
      if (playerItemLi && playerItemLi.dataset.active === 'true') singleRoll(playerItemLi); // Auto-roll if active
    });
    dropdownListContainer.appendChild(item);
  });
}

// Global click listener to close dropdowns (moved to global scope)
document.addEventListener('click', (event) => {
  const openDropdowns = document.querySelectorAll('.player-name-dropdown-list.open');
  openDropdowns.forEach(dropdown => {
    // Check if the click was outside the dropdown and its associated input wrapper
    if (!dropdown.closest('.player-name-wrapper').contains(event.target)) {
      dropdown.classList.remove('open');
    }
  });
});

// --- End Functions for Name Dropdown ---

function currentCounts(){const c={vanguard:0,duellist:0,strategist:0,flex:0};[...list.children].forEach(li=>{const r=li.dataset.lastRole;if(r)c[r]++;});return c;}
function updateUI(){
  const c = list.children.length;
  // const hasEmptySlot = [...list.children].some(item => !item.querySelector('.player-name').value.trim());
  // addBtn related lines removed
  
  list.querySelectorAll('.remove').forEach(b=>{
    b.disabled = c <= MIN_PLAYERS; 
    b.classList.toggle('disabled',b.disabled);
  });
}

// Function to display a temporary message below the minimums heading
function displayTemporaryMessage(message) {
  const warningElement = document.getElementById('minimumsWarning');
  if (warningElement) {
    warningElement.textContent = message;
    warningElement.style.display = 'block'; // Make it visible

    setTimeout(() => {
      warningElement.textContent = '';
      warningElement.style.display = 'none'; // Hide it after 3 seconds
    }, 3000);
  }
}

function validateAndAdjustMinimums(changedInput) {
  const currentMinimums = {
    vanguard: parseInt(vanguardMinInput.value) || 0,
    duellist: parseInt(duellistMinInput.value) || 0,
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  const sumOfMinimums = Object.values(currentMinimums).reduce((sum, val) => sum + val, 0);

  if (sumOfMinimums > 6) {
    const excess = sumOfMinimums - 6;
    let changedInputValue = parseInt(changedInput.value) || 0;
    let newChangedValue = changedInputValue - excess;

    if (newChangedValue < 0) newChangedValue = 0; // Ensure it doesn't go below 0
    changedInput.value = newChangedValue;

    // Display warning message instead of alert
    const roleName = changedInput.id.replace('Min', '');
    displayTemporaryMessage(`Sum of minimums cannot exceed 6. ${roleName.charAt(0).toUpperCase() + roleName.slice(1)} Min has been adjusted.`);
  }

  // After validation/adjustment, check if current assignments meet new minimums
  const finalMinimums = {
    vanguard: parseInt(vanguardMinInput.value) || 0,
    duellist: parseInt(duellistMinInput.value) || 0,
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  const currentRoleCounts = currentCounts(); // Get current actual counts of roles

  let needsReroll = false;
  if (currentRoleCounts.vanguard < finalMinimums.vanguard) needsReroll = true;
  if (currentRoleCounts.duellist < finalMinimums.duellist) needsReroll = true;
  if (currentRoleCounts.strategist < finalMinimums.strategist) needsReroll = true;
  if (currentRoleCounts.flex < finalMinimums.flex) needsReroll = true;
  
  // Log values for debugging
  console.log("--- Min Change Check ---");
  console.log("Final Minimums:", JSON.stringify(finalMinimums));
  console.log("Current Role Counts:", JSON.stringify(currentRoleCounts));
  console.log("Needs Reroll Flag Before Check:", needsReroll);

  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true');
  const sumOfFinalMinimums = Object.values(finalMinimums).reduce((sum, val) => sum + val, 0);

  console.log("Active Players Count:", activePlayers.length);
  console.log("Sum of Final Minimums:", sumOfFinalMinimums);

  // Only reroll if needed AND it's possible to satisfy the sum of minimums with the current player count
  if (needsReroll && activePlayers.length > 0 && activePlayers.length >= sumOfFinalMinimums) {
    displayTemporaryMessage('Minimums changed and are satisfiable, rerolling all players...');
    rollAll();
  } else if (needsReroll && activePlayers.length > 0 && activePlayers.length < sumOfFinalMinimums) {
    displayTemporaryMessage('Minimums changed, but cannot be met with current player count.');
    console.log("Reroll skipped: Not enough active players to meet the sum of new minimums.");
  }
}

function weightedDifferentRole(li, counts, minimums) {
  const lastRole = li.dataset.lastRole;
  const streak = parseInt(li.dataset.streak || '0', 10);
  let newRole;
  let tries = 0;
  const allRolesWithMinimums = [...BASE_ROLES, 'flex'];

  // 1. Check if any role is now below its minimum due to this player's role being removed from 'counts'.
  //    'counts' is the team's role distribution *before* this player gets a new role (i.e., their old role slot is vacant).
  const rolesNeededForMinimums = allRolesWithMinimums.filter(r => counts[r] < minimums[r]);
  if (rolesNeededForMinimums.length > 0) {
    // If player's lastRole is one of the critically needed roles, or if not rotating, prioritize it.
    // Otherwise, pick from any of the needed roles.
    // This ensures minimums are strictly met first.
    shuffle(rolesNeededForMinimums);
    newRole = rolesNeededForMinimums[0]; 
    // Apply streak prevention here if the only way to meet minimums is to repeat the last role.
    if (newRole === lastRole && streak >= 2) {
        if (Math.random() < 0.7 && rolesNeededForMinimums.length === 1 && rolesNeededForMinimums[0] === lastRole) {
            // Highly constrained: only one role fixes minimums, and it's a streak.
            // We are forced to pick it. Or, if there were other options in rolesNeededForMinimums, shuffle might pick a different one.
        } else if (rolesNeededForMinimums.length > 1) {
            // Try to pick a different needed role if lastRole was also needed
            let otherNeededRoles = rolesNeededForMinimums.filter(r => r !== lastRole);
            if (otherNeededRoles.length > 0) {
                shuffle(otherNeededRoles);
                newRole = otherNeededRoles[0];
            }
        }
    }
    applyRole(li, newRole);
    return newRole; // Exit early, minimums dictated the choice.
  }

  // If we are here, all minimums are currently met by the team composition in 'counts'.
  // Now, try to select a role, respecting Rotate Roles preference.
  do {
    tries++;
    let candidateRoles = [];
    allRolesWithMinimums.forEach(r => {
      // A role is a candidate if there's space for it, and its own minimum is currently met by the team.
      if (counts[r] < MAX_PLAYERS && minimums[r] <= counts[r]) {
        candidateRoles.push(r);
      }
    });

    // Add Flex by chance if it's not already a candidate due to its own min (e.g., flexMin=0)
    // and it has space and its minimum is met.
    if (flexChance() && !candidateRoles.includes('flex') && counts['flex'] < MAX_PLAYERS && minimums['flex'] <= counts['flex']) {
      candidateRoles.push('flex');
    }

    if (candidateRoles.length === 0) {
      // Fallback: if no roles are "open" (e.g. all are exactly at min and no flex space),
      // broaden to any role that simply has space, as global minimums ARE met.
      candidateRoles = allRolesWithMinimums.filter(r => counts[r] < MAX_PLAYERS);
      if (candidateRoles.length === 0) { // All roles are at MAX_PLAYERS
        newRole = lastRole || allRolesWithMinimums[rng(0, allRolesWithMinimums.length - 1)];
        break; // Absolute fallback if team is literally full for all roles.
      }
    }

    let chosenRole;
    if (rotateRolesCB && rotateRolesCB.checked && lastRole && candidateRoles.includes(lastRole)) {
      const alternativeCandidates = candidateRoles.filter(r => r !== lastRole);
      if (alternativeCandidates.length > 0) {
        shuffle(alternativeCandidates);
        chosenRole = alternativeCandidates[0];
      } else {
        // No alternatives, or lastRole wasn't a candidate to begin with (shouldn't happen if .includes was true)
        chosenRole = lastRole; // Must stick if it's the only valid option among candidates
      }
    } else {
      // Rotate not checked, or no lastRole, or lastRole not among current candidates.
      shuffle(candidateRoles);
      chosenRole = candidateRoles[0];
    }
    newRole = chosenRole;

    // Streak Prevention: Applied to the chosen role (which might have been rotated)
    if (newRole === lastRole && streak >= 2) {
      if (Math.random() < 0.7) { // 70% chance to reroll selection process
        if (tries < 50) continue; // Try the whole selection again
      }
    }
    break; // Role selected, or streak prevention attempts exhausted
  } while (tries < 50);

  return newRole || lastRole || allRolesWithMinimums[rng(0, allRolesWithMinimums.length - 1)]; // Final fallback
}
function applyRole(li,role){
  const iconImg = li.querySelector('.role-icon');
  const roleSpan = li.querySelector('.role-name'); 
  const heroSpan = li.querySelector('.suggested-hero');

  // Remove any existing role overlay classes
  ROLE_OVERLAY_CLASSES.forEach(cls => li.classList.remove(cls));

  if (role) {
    iconImg.src = ICONS[role];
    iconImg.style.display = 'inline-block';
    roleSpan.textContent=role.charAt(0).toUpperCase()+role.slice(1);

    // Add new overlay class
    if (role === 'strategist') li.classList.add('role-overlay-strategist');
    else if (role === 'vanguard') li.classList.add('role-overlay-vanguard');
    else if (role === 'duellist') li.classList.add('role-overlay-duellist');
    else if (role === 'flex') li.classList.add('role-overlay-flex');

    if (BASE_ROLES.includes(role)) {
      const heroList = HEROES_BY_ROLE[role.charAt(0).toUpperCase() + role.slice(1)];
      if (heroList && heroList.length > 0) {
        const randomHero = heroList[rng(0, heroList.length - 1)];
        heroSpan.textContent = `${randomHero}`;
      } else {
        heroSpan.textContent = 'No heroes listed';
      }
    } else {
      heroSpan.textContent = '';
    }
  } else { // No role or cleared role
    iconImg.src = '';
    iconImg.style.display = 'none';
    roleSpan.textContent = 'No Role';
    heroSpan.textContent = '';
    // Overlay classes already cleared
  }

  const last=li.dataset.lastRole;
  li.dataset.streak=(role===last?parseInt(li.dataset.streak||'0',10)+1:1);
  li.dataset.lastRole=role;
}

// New function to update dice dots based on player index
function updateDiceDots() {
  const players = [...list.children];
  players.forEach((li, index) => {
    const diceFace = index + 1; // Player 1 is index 0, corresponds to dice face 1
    const svg = li.querySelector('.roll svg');
    if (!svg) return;

    // Hide all dots initially
    svg.querySelectorAll('circle').forEach(circle => circle.style.display = 'none');

    // Show dots based on dice face number (player index + 1)
    switch (diceFace) {
      case 1:
        svg.querySelector('#dot-center').style.display = 'inline';
        break;
      case 2:
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 3:
        svg.querySelector('#dot-center').style.display = 'inline';
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 4:
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-tr').style.display = 'inline';
        svg.querySelector('#dot-bl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 5:
        svg.querySelector('#dot-center').style.display = 'inline';
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-tr').style.display = 'inline';
        svg.querySelector('#dot-bl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 6:
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-tr').style.display = 'inline';
        svg.querySelector('#dot-bl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        svg.querySelector('#dot-mid-l').style.display = 'inline';
        svg.querySelector('#dot-mid-r').style.display = 'inline';
        break;
      default:
        // For indices > 5 or other cases, show no dots
        break;
    }
  });
}

function singleRoll(li){
  const counts=currentCounts();
  counts[li.dataset.lastRole]--;
  let newRole;
  let tries = 0;
  const minimums = { 
    vanguard: parseInt(vanguardMinInput.value) || 0, 
    duellist: parseInt(duellistMinInput.value) || 0, 
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  do {
    newRole = weightedDifferentRole(li, counts, minimums);
    tries++;
  } while (newRole === li.dataset.lastRole && tries < 40);
  applyRole(li, newRole);
  if (autoSortCB.checked) {
    sortPlayers(li, true); // Pass rolled LI and true to animate
  }
  // Add player name to quick list if not empty
  const playerNameInput = li.querySelector('.player-name');
  if (playerNameInput && playerNameInput.value.trim() !== '') {
    addNameToQuickList(playerNameInput.value.trim());
  }
  updateDiceDots(); // Update dice dots after a single roll (in case sort changes index)
}
function rollAll(){
  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true');
  if (activePlayers.length === 0) return; 

  // Save the current team names before rolling
  const currentTeamNames = activePlayers.map(li => li.querySelector('.player-name').value.trim()).filter(name => name !== '');
  if (currentTeamNames.length > 0) {
    localStorage.setItem(LAST_ROLL_ALL_TEAM_KEY, JSON.stringify(currentTeamNames));
  }

  const counts={vanguard:0,duellist:0,strategist:0,flex:0};
  const minimums = { 
    vanguard: parseInt(vanguardMinInput.value) || 0, 
    duellist: parseInt(duellistMinInput.value) || 0, 
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };

  let playersToAssign = [...activePlayers];
  let assignedCounts = {vanguard:0,duellist:0,strategist:0,flex:0};

  playersToAssign.forEach(pLi => {
      const role = weightedDifferentRole(pLi, assignedCounts, minimums);
      applyRole(pLi, role);
      assignedCounts[role]++;
      // Add player name to quick list if not empty
      const playerNameInput = pLi.querySelector('.player-name');
      if (playerNameInput && playerNameInput.value.trim() !== '') {
        addNameToQuickList(playerNameInput.value.trim());
      }
  });
  
  if (autoSortCB.checked) { 
    sortPlayers(null, ANIMATE_ROLL_ALL_SORT); // Pass null and config for animation
  }
  updateDiceDots(); // Update dice dots after roll all (order might change if sorted)
}
function copyPlayersPlainText(){
  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true' && li.querySelector('.player-name').value.trim() !== '');
  if(activePlayers.length === 0) {
    displayTemporaryMessage('No active players with names to copy!');
    return;
  }
  let text = 'Marvel Rivals Roles:';
  activePlayers.forEach(li => {
    const name = li.querySelector('.player-name').value.trim(); // Use .player-name input
    const role = li.querySelector('.role-name').textContent;
    const suggestedHero = li.querySelector('.suggested-hero').textContent.trim();
    text += `\n${name}: ${role}${suggestedHero ? ' (' + suggestedHero + ')' : ''}`; // Added parenthesis for suggested hero
  });
  navigator.clipboard.writeText(text).then(() => {
    displayTemporaryMessage('Player roles (plain text) copied!');
  }, () => {
    displayTemporaryMessage('Failed to copy plain text.');
  });
}

function copyPlayersTSV() {
  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true' && li.querySelector('.player-name').value.trim() !== '');
  if (activePlayers.length === 0) {
    displayTemporaryMessage('No active players with names to copy for TSV!');
    return;
  }

  let tsvString = "Player Name\tRole\tSuggested Hero\n"; // Header row

  activePlayers.forEach(li => {
    const nameInput = li.querySelector('.player-name');
    const name = nameInput ? nameInput.value.trim() : 'Unnamed Player';
    const role = li.querySelector('.role-name').textContent.trim();
    const suggestedHero = li.querySelector('.suggested-hero').textContent.trim();
    
    tsvString += `${name}\t${role}\t${suggestedHero}\n`;
  });

  navigator.clipboard.writeText(tsvString.trim()).then(() => {
    displayTemporaryMessage('Player data copied to clipboard (TSV)!');
  }, (err) => {
    displayTemporaryMessage('Failed to copy TSV to clipboard.');
    console.error('TSV Copy Error:', err);
  });
}


// Function to sort players by role (Vanguard, Duellist, Strategist, Flex)
function sortPlayers(rolledLiElement = null, animateThisSort = true) {
  if (!autoSortCB.checked) { // If auto-sort is off, just do a simple sort and return
    const players = [...list.children];
    const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
    players.sort((a, b) => {
      const roleA = a.dataset.lastRole.toLowerCase();
      const roleB = b.dataset.lastRole.toLowerCase();
      const indexA = roleOrder.indexOf(roleA);
      const indexB = roleOrder.indexOf(roleB);
      if (indexA === -1 && indexB === -1) return 0;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    players.forEach(player => list.appendChild(player));
    return;
  }

  if (!animateThisSort) { // If this specific sort call shouldn't be animated (e.g. Roll All with config off)
    const players = [...list.children];
    const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
    players.sort((a, b) => {
      const roleA = a.dataset.lastRole.toLowerCase();
      const roleB = b.dataset.lastRole.toLowerCase();
      const indexA = roleOrder.indexOf(roleA);
      const indexB = roleOrder.indexOf(roleB);
      if (indexA === -1 && indexB === -1) return 0;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    players.forEach(player => list.appendChild(player));
    return;
  }

  const playersLiElements = [...list.children];
  const oldPositions = new Map();

  // 1. First: Record initial positions (offsetTop relative to the list)
  playersLiElements.forEach(li => {
    oldPositions.set(li, li.offsetTop);
  });

  // --- Actual Sorting (JS array sort) ---
  const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
  const originalRolledIndex = rolledLiElement ? playersLiElements.indexOf(rolledLiElement) : -1;

  const sortedPlayerLiElements = [...playersLiElements].sort((a, b) => {
    const roleA = a.dataset.lastRole.toLowerCase();
    const roleB = b.dataset.lastRole.toLowerCase();
    const indexA = roleOrder.indexOf(roleA);
    const indexB = roleOrder.indexOf(roleB);
    if (indexA === -1 && indexB === -1) return 0;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });

  // --- Update DOM Order ---
  sortedPlayerLiElements.forEach(li => list.appendChild(li));

  // Update dice dots after sorting
  updateDiceDots();

  const newRolledIndex = rolledLiElement ? sortedPlayerLiElements.indexOf(rolledLiElement) : -1;
  const rolledCardMoved = originalRolledIndex !== -1 && newRolledIndex !== -1 && originalRolledIndex !== newRolledIndex;

  // Apply a temporary highlight to the rolled card, regardless of movement for single rolls
  if (rolledLiElement && animateThisSort) { // animateThisSort is true for single rolls
    rolledLiElement.classList.add('rolled-highlight');
    setTimeout(() => {
      rolledLiElement.classList.remove('rolled-highlight');
    }, 700); // Highlight duration
  }

  // --- Invert & Play ---
  sortedPlayerLiElements.forEach(li => {
    const oldTop = oldPositions.get(li);
    if (typeof oldTop !== 'number') return; 

    const newTop = li.offsetTop;
    const deltaY = oldTop - newTop;

    li.style.transition = 'none'; // Disable transitions for the setup
    let transformStyle = `translateY(${deltaY}px)`;

    if (li === rolledLiElement && rolledCardMoved) { // Only scale and elevate if it actually moved
      li.style.zIndex = '10';
      transformStyle += ' scale(1.05)';
    }
    li.style.transform = transformStyle;
  });

  // Force reflow to apply the transform styles before starting the animation
  void list.offsetWidth;

  // Play: Transition to new positions
  sortedPlayerLiElements.forEach(li => {
    li.style.transition = 'transform 0.5s ease-in-out';
    if (li === rolledLiElement && rolledCardMoved) { // Ensure z-index also transitions if it was changed
      li.style.transition = 'transform 0.5s ease-in-out, z-index 0s linear 0.5s';
    }
    li.style.transform = 'translateY(0px) scale(1)';

    li.addEventListener('transitionend', function handler() {
      li.style.transition = '';
      if (li === rolledLiElement && rolledCardMoved) { // Only reset zIndex if it was set
        li.style.zIndex = '';
      }
      // Keep transform at scale(1) translateY(0) - it's the natural state now
      li.removeEventListener('transitionend', handler);
    }, { once: true });
  });
}

// Function to update the text of the dark mode button
function updateDarkModeButtonText() {
    const darkBtn = document.getElementById('darkBtn');
    if (document.body.classList.contains('dark-mode')) {
        darkBtn.textContent = 'Switch to Light Mode';
    } else {
        darkBtn.textContent = 'Switch to Dark Mode';
    }
}

// Initialize the application after DOM is loaded and heroes are fetched
document.addEventListener('DOMContentLoaded', async () => {
  await loadHeroes(); 
  document.body.classList.add('dark-mode');
  updateDarkModeButtonText(); 

  const playerPanel = document.querySelector('.player-panel'); 
  const quickRow = document.querySelector('.quick-populate-row'); 
  if (playerPanel && quickRow) {
    playerPanel.appendChild(quickRow);
    const editNamesBtn = document.createElement('button');
    editNamesBtn.textContent = 'Edit Names';
    editNamesBtn.className = 'edit-names-btn';
    playerPanel.appendChild(editNamesBtn); 
    let isEditMode = false;
    editNamesBtn.addEventListener('click', () => {
      isEditMode = !isEditMode;
      renderQuickPopulateButtons(isEditMode);
      editNamesBtn.textContent = isEditMode ? 'Done Editing' : 'Edit Names';
    });
  }

  rollAllBtn.addEventListener('click',rollAll);
  document.getElementById('copyPlainTextBtn').addEventListener('click', copyPlayersPlainText);
  darkBtn.addEventListener('click',()=>{
    document.body.classList.toggle('dark-mode');
    updateDarkModeButtonText(); 
  });

  [vanguardMinInput, duellistMinInput, strategistMinInput, flexMinInput].forEach(input => {
    input.addEventListener('input', () => validateAndAdjustMinimums(input));
  });

  document.querySelectorAll('.min-adjust-btn').forEach(button => {
    button.addEventListener('click', () => {
      const input = button.closest('.option-group').querySelector('input[type="number"]');
      const direction = button.dataset.direction;
      const currentValue = parseInt(input.value) || 0;
      const step = parseInt(input.step) || 1; 
      const minValue = parseInt(input.min) || 0; 
      const maxValue = parseInt(input.max) || 6; 
      let newValue;
      if (direction === 'increment') newValue = currentValue + step;
      else newValue = currentValue - step;
      if (newValue >= minValue && newValue <= maxValue) {
        if (direction === 'increment') {
            const currentMinimumsSum = parseInt(vanguardMinInput.value || 0) + parseInt(duellistMinInput.value || 0) + parseInt(strategistMinInput.value || 0) + parseInt(flexMinInput.value || 0);
            const proposedSum = currentMinimumsSum - currentValue + newValue; 
            if (proposedSum > MAX_PLAYERS) { 
              displayTemporaryMessage(`Sum of minimums cannot exceed ${MAX_PLAYERS}.`);
              return; 
            }
        }
        input.value = newValue;
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
  });

  // Restore Pre-populate players from LAST_ROLL_ALL_TEAM_KEY
  const lastTeamJSON = localStorage.getItem(LAST_ROLL_ALL_TEAM_KEY);
  let teamNamesToLoad = [];
  if (lastTeamJSON) {
    try {
      const parsedTeam = JSON.parse(lastTeamJSON);
      if (Array.isArray(parsedTeam) && parsedTeam.every(name => typeof name === 'string')) {
        teamNamesToLoad = parsedTeam;
      }
    } catch (e) { /* Ignore parsing errors, will load empty team */ }
  }

  if (teamNamesToLoad.length > 0) {
    teamNamesToLoad.forEach(name => {
      if (list.children.length < MAX_PLAYERS) {
        addPlayer(); 
        const lastPlayerItem = list.lastChild;
        if (lastPlayerItem) {
          const nameInput = lastPlayerItem.querySelector('.player-name');
          if (nameInput) {
            nameInput.value = name;
          }
        }
      }
    });
    // After populating all names, update states, then roll.
    updateAllPlayerStates(); // Update active states for all pre-populated players
    rollAll(); 
  } else {
    // Fallback: If no last team, add MIN_PLAYERS slots, ensuring at least 1
    if (list.children.length === 0) { 
      const initialSlotsToAdd = Math.max(1, MIN_PLAYERS);
      for (let i = 0; i < initialSlotsToAdd; i++) {
        if (list.children.length < MAX_PLAYERS) {
          addPlayer();
        }
      }
    }
  }
  
  renderQuickPopulateButtons(); 
  updateQuickPopButtons();
  updateDiceDots(); 
});

const QUICK_NAMES_STORAGE_KEY = 'rivalsRollerQuickNames';
const LAST_ROLL_ALL_TEAM_KEY = 'rivalsRollerLastTeam'; // Ensure this key is defined

function getQuickNames() {
  const storedNames = localStorage.getItem(QUICK_NAMES_STORAGE_KEY);
  try {
    const parsed = JSON.parse(storedNames);
    if (Array.isArray(parsed)) {
      // Ensure all items are strings and not empty after trimming
      return parsed.map(item => String(item).trim()).filter(item => item !== '');
    }
    return [];
  } catch (e) {
    return [];
  }
}

function saveQuickNames(namesArray) {
  // Ensure only unique, non-empty, trimmed strings are saved
  const uniqueNames = [...new Set(namesArray.map(name => String(name).trim()).filter(name => name !== ''))];
  localStorage.setItem(QUICK_NAMES_STORAGE_KEY, JSON.stringify(uniqueNames));
}

function addNameToQuickList(name) { // Updates simple array of strings
  if (!name || name.trim() === '') return;
  const currentNames = getQuickNames();
  const trimmedName = name.trim();
  if (!currentNames.includes(trimmedName)) {
    currentNames.push(trimmedName);
    saveQuickNames(currentNames);
  }
  // No need to re-render quick-pop buttons here directly as addPlayer/input events will handle it.
  // The original renderQuickPopulateButtons sorting by name is fine.
}

function renderQuickPopulateButtons(editMode = false) {
  const quickRow = document.querySelector('.player-panel .quick-populate-row');
  if (!quickRow) return;
  quickRow.innerHTML = ''; 
  const names = getQuickNames(); // Now a simple array of strings

  names.sort((a, b) => a.localeCompare(b)); // Sort alphabetically

  names.forEach(name => { // name is now a string directly
    const btnContainer = document.createElement('div');
    btnContainer.className = 'quick-pop-btn-container';
    if (editMode) {
        btnContainer.classList.add('edit-mode');
    }

    const btn = document.createElement('button');
    btn.textContent = name;
    btn.className = 'quick-pop-btn';
    if (editMode) {
        btn.classList.add('edit-mode');
    }
    
    btn.addEventListener('click', () => {
      if (editMode) return; // Don't populate if in edit mode

      let playerInputs = [...list.querySelectorAll('input.player-name')];
      let filled = false;
      for (let inp of playerInputs) {
        if (!inp.value.trim()) {
          inp.value = name;
          updateQuickPopButtons(); 
          updateAllPlayerStates(); 
          const playerItemLi = inp.closest('.player-item'); // Get the li
          if (playerItemLi && playerItemLi.dataset.active === 'true') singleRoll(playerItemLi); // Auto-roll if active
          filled = true;
          break;
        }
      }
      if (!filled && list.children.length < MAX_PLAYERS) {
        addPlayer(); 
        let newInput = list.lastChild.querySelector('input.player-name');
        if (newInput) {
            newInput.value = name;
            updateQuickPopButtons(); 
            updateAllPlayerStates(); 
            if (list.lastChild && list.lastChild.dataset.active === 'true') singleRoll(list.lastChild); 
        }
      }
    });

    btnContainer.appendChild(btn);

    if (editMode) {
      const removeIcon = document.createElement('span');
      removeIcon.className = 'remove-name-icon';
      removeIcon.innerHTML = '&times;'; // Use &times; for a nice X icon
      removeIcon.title = 'Remove this name';
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation(); 
        const nameToRemove = name; // Capture the correct name from the outer scope
        
        // 1. Remove from QUICK_NAMES_STORAGE_KEY
        const currentQuickNames = getQuickNames();
        const updatedQuickNames = currentQuickNames.filter(n => n !== nameToRemove);
        saveQuickNames(updatedQuickNames);

        // 2. Remove from LAST_ROLL_ALL_TEAM_KEY
        const lastTeamJSON = localStorage.getItem(LAST_ROLL_ALL_TEAM_KEY);
        if (lastTeamJSON) {
          try {
            let lastTeam = JSON.parse(lastTeamJSON);
            if (Array.isArray(lastTeam)) {
              const updatedLastTeam = lastTeam.filter(n => n !== nameToRemove);
              localStorage.setItem(LAST_ROLL_ALL_TEAM_KEY, JSON.stringify(updatedLastTeam));
            }
          } catch (err) {
            console.error('Error processing LAST_ROLL_ALL_TEAM_KEY during name removal:', err);
            // Decide if we want to clear it or leave it if corrupted
          }
        }
        
        renderQuickPopulateButtons(true); // Re-render buttons in edit mode
      });
      btnContainer.appendChild(removeIcon);
    }
    quickRow.appendChild(btnContainer);
  });
  updateQuickPopButtons(); // Update used state for all buttons
}

// Function to update the state of quick populate buttons
function updateQuickPopButtons() {
  const playerNames = [...list.querySelectorAll('input.player-name')].map(input => input.value.trim()).filter(name => name !== '');
  const quickPopButtons = document.querySelectorAll('.player-panel .quick-pop-btn'); // Ensure targeting within player-panel

  quickPopButtons.forEach(button => {
    const name = button.textContent;
    if (playerNames.includes(name)) {
      button.classList.add('used');
      button.disabled = true; 
    } else {
      button.classList.remove('used');
      button.disabled = false; 
    }
  });
}

// New function to update active states and auto-add player
function updateAllPlayerStates() {
  const players = [...list.children];
  let allActive = true;
  let activePlayerCount = 0;

  players.forEach(li => {
    const nameInput = li.querySelector('.player-name');
    const rollButton = li.querySelector('.roll');
    if (nameInput.value.trim() !== '') {
      li.dataset.active = 'true';
      rollButton.disabled = false;
      rollButton.classList.remove('disabled');
      activePlayerCount++;
    } else {
      li.dataset.active = 'false';
      rollButton.disabled = true;
      rollButton.classList.add('disabled');
      allActive = false; // If any is empty, not all are active
    }
  });

  // Auto-add new player if all existing have names and we are below max players
  if (allActive && players.length > 0 && players.length < MAX_PLAYERS) {
    addPlayer();
  }
  updateUI();
  updateDiceDots(); // Update dice dots after potential auto-add
}

// Update dice dots whenever the list children change (add/remove/sort)
const observer = new MutationObserver(updateDiceDots);
observer.observe(list, { childList: true });
</script>
<div class="quick-populate-row">
</div>
</body>
</html>
