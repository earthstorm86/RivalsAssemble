<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Marvel Rivals Rollâ€‘Aâ€‘Roller</title>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <div class="logo"><img src="images/logo-small.png" alt="Rivals Assemble  " width="237" height="177"></div>
  <div class="main">
    <section class="panel player-panel"><h2>Player List</h2><ul id="playerList" class="player-list"></ul></section>
    <section class="panel options-panel"><h2>Options</h2>
      <button id="addBtn">Add Player</button>
      <button id="rollAllBtn">Roll All</button>
      <button id="captureBtn">Copy to clipboard</button>
      <button id="darkBtn">Dark Mode</button>
      <div class="role-options-section">
        <h3>Minimums</h3>
        <div id="minimumsWarning" class="warning-message"></div>
        <div class="min-inputs-grid">
          <div class="option-group">
            <label for="vanguardMin">Vanguard</label>
            <div class="min-input-controls">
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="vanguardMin" value="1" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
          </div>
          <div class="option-group">
            <label for="duellistMin">Duellist</label>
            <div class="min-input-controls">
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="duellistMin" value="2" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
          </div>
          <div class="option-group">
            <label for="strategistMin">Strategist</label>
            <div class="min-input-controls">
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="strategistMin" value="2" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
          </div>
          <div class="option-group">
            <label for="flexMin">Flex</label>
            <div class="min-input-controls">
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="flexMin" value="0" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
          </div>
        </div>
        <label id="lblAutoSort"><input type="checkbox" id="autoSortCB" checked>Auto Sort Roles</label>
      </div>
    </section>
  </div>
<script>
const ANIMATE_ROLL_ALL_SORT = false; // Config option for animating sort on Roll All
let HEROES_BY_ROLE = {}; // Initialize as empty object

const ROLE_OVERLAY_CLASSES = [
  'role-overlay-strategist',
  'role-overlay-vanguard',
  'role-overlay-duellist',
  'role-overlay-flex'
];

async function loadHeroes() {
  try {
    const response = await fetch('data/heroes.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    HEROES_BY_ROLE = await response.json();
    console.log('Heroes loaded:', HEROES_BY_ROLE);
  } catch (error) {
    console.error('Could not load heroes:', error);
    // Optionally, set some default/empty hero lists or alert the user
    HEROES_BY_ROLE = {
      "Strategist": ["Error loading heroes"],
      "Vanguard": ["Error loading heroes"],
      "Duellist": ["Error loading heroes"]
    };
  }
}

const MIN_PLAYERS=2,MAX_PLAYERS=6;
const ICONS={vanguard:'images/VanguardIcon.png',duellist:'images/DuellistIcon.png',strategist:'images/StrategistIcon.png',flex:'images/FlexIcon.png'};
const BASE_ROLES=['vanguard','duellist','strategist'];
const list=document.getElementById('playerList');
const addBtn=document.getElementById('addBtn');
const rollAllBtn=document.getElementById('rollAllBtn');
const captureBtn=document.getElementById('captureBtn');
const darkBtn=document.getElementById('darkBtn');
const vanguardMinInput = document.getElementById('vanguardMin');
const duellistMinInput = document.getElementById('duellistMin');
const strategistMinInput = document.getElementById('strategistMin');
const flexMinInput = document.getElementById('flexMin');
const autoSortCB = document.getElementById('autoSortCB');
const rng=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=rng(0,i);[a[i],a[j]]=[a[j],a[i]];}return a;};
const flexChance=()=>Math.random()<0.05;

function addPlayer(){if(list.children.length>=MAX_PLAYERS)return;const li=document.createElement('li');li.className='player-item';li.dataset.active = 'false'; // Initially inactive
li.innerHTML=`
  <button class="remove" title="Remove">Ã—</button>
  <div class="player-name-wrapper">
    <input class="player-name" type="text" placeholder="Name">
    <button class="player-name-dropdown-arrow" title="Show saved names">â–¼</button>
    <div class="player-name-dropdown-list"></div>
  </div>
  <div class="role-info">
    <img class="role-icon" src="">
    <span class="role-name">No Role</span>
    <span class="suggested-hero"></span>
  </div>
  <button class="roll" title="Roll">ðŸŽ²</button>
`;li.dataset.lastRole='';li.dataset.streak='0';
const playerNameInput = li.querySelector('.player-name');
const dropdownArrow = li.querySelector('.player-name-dropdown-arrow');
const rollButton = li.querySelector('.roll'); // Get roll button

rollButton.disabled = true; // Disable roll button initially

li.querySelector('.remove').addEventListener('click',()=>{li.remove();updateUI();updateQuickPopButtons();updateAllPlayerStates();});
rollButton.addEventListener('click',()=>singleRoll(li));
playerNameInput.addEventListener('input', ()=>{
  updateQuickPopButtons();
  updateAllPlayerStates();
});
dropdownArrow.addEventListener('click', (e) => {
  e.stopPropagation(); 
  toggleNameDropdown(playerNameInput, dropdownArrow);
});

list.append(li);updateUI();updateQuickPopButtons();updateAllPlayerStates();}

// --- Functions for Name Dropdown (moved to global scope) ---
function toggleNameDropdown(inputElement, arrowButton) {
  const wrapper = inputElement.closest('.player-name-wrapper');
  const dropdownList = wrapper.querySelector('.player-name-dropdown-list');
  const isOpen = dropdownList.classList.toggle('open');
  if (isOpen) {
    renderNameDropdownList(inputElement, dropdownList);
  }
}

function renderNameDropdownList(inputElement, dropdownListContainer) {
  const currentInputValue = inputElement.value.trim();
  const allNames = getQuickNames();
  const namesToShow = allNames.filter(name => name.toLowerCase() !== currentInputValue.toLowerCase());

  dropdownListContainer.innerHTML = ''; // Clear previous items

  if (namesToShow.length === 0) {
    const noNamesItem = document.createElement('div');
    noNamesItem.textContent = 'No other saved names';
    noNamesItem.style.padding = '0.6rem 0.8rem';
    noNamesItem.style.color = '#888';
    dropdownListContainer.appendChild(noNamesItem);
    return;
  }

  namesToShow.forEach(name => {
    const item = document.createElement('div');
    item.className = 'player-name-dropdown-item';
    item.textContent = name;
    item.addEventListener('click', () => {
      inputElement.value = name;
      dropdownListContainer.classList.remove('open');
      // Trigger input event to update quick pop buttons and for other listeners
      inputElement.dispatchEvent(new Event('input', { bubbles: true })); 
    });
    dropdownListContainer.appendChild(item);
  });
}

// Global click listener to close dropdowns (moved to global scope)
document.addEventListener('click', (event) => {
  const openDropdowns = document.querySelectorAll('.player-name-dropdown-list.open');
  openDropdowns.forEach(dropdown => {
    // Check if the click was outside the dropdown and its associated input wrapper
    if (!dropdown.closest('.player-name-wrapper').contains(event.target)) {
      dropdown.classList.remove('open');
    }
  });
});

// --- End Functions for Name Dropdown ---

function currentCounts(){const c={vanguard:0,duellist:0,strategist:0,flex:0};[...list.children].forEach(li=>{const r=li.dataset.lastRole;if(r)c[r]++;});return c;}
function updateUI(){
  const c = list.children.length;
  const hasEmptySlot = [...list.children].some(item => !item.querySelector('.player-name').value.trim());
  
  addBtn.disabled = c >= MAX_PLAYERS || (c > 0 && hasEmptySlot && c < MAX_PLAYERS);
  addBtn.classList.toggle('disabled',addBtn.disabled);
  
  list.querySelectorAll('.remove').forEach(b=>{
    b.disabled = c <= MIN_PLAYERS; 
    b.classList.toggle('disabled',b.disabled);
  });
}

// Function to display a temporary message below the minimums heading
function displayTemporaryMessage(message) {
  const warningElement = document.getElementById('minimumsWarning');
  if (warningElement) {
    warningElement.textContent = message;
    warningElement.style.display = 'block'; // Make it visible

    setTimeout(() => {
      warningElement.textContent = '';
      warningElement.style.display = 'none'; // Hide it after 3 seconds
    }, 3000);
  }
}

function validateAndAdjustMinimums(changedInput) {
  const currentMinimums = {
    vanguard: parseInt(vanguardMinInput.value) || 0,
    duellist: parseInt(duellistMinInput.value) || 0,
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  const sumOfMinimums = Object.values(currentMinimums).reduce((sum, val) => sum + val, 0);

  if (sumOfMinimums > 6) {
    const excess = sumOfMinimums - 6;
    let changedInputValue = parseInt(changedInput.value) || 0;
    let newChangedValue = changedInputValue - excess;

    if (newChangedValue < 0) newChangedValue = 0; // Ensure it doesn't go below 0
    changedInput.value = newChangedValue;

    // Display warning message instead of alert
    const roleName = changedInput.id.replace('Min', '');
    displayTemporaryMessage(`Sum of minimums cannot exceed 6. ${roleName.charAt(0).toUpperCase() + roleName.slice(1)} Min has been adjusted.`);
  }
}

function weightedDifferentRole(li, counts, minimums) {
  const last=li.dataset.lastRole,streak=parseInt(li.dataset.streak||'0',10);
  let role;
  let tries=0;
  // Include flex in roles that can have minimums
  const allRolesWithMinimums = [...BASE_ROLES, 'flex'];

  // 1. Prioritize roles that are below their specified minimums
  const rolesNeededForMinimums = allRolesWithMinimums.filter(r => counts[r] < minimums[r]);
  if (rolesNeededForMinimums.length > 0) {
    shuffle(rolesNeededForMinimums);
    return rolesNeededForMinimums[0]; // Assign a role needed to meet minimums
  }

  // 2. If minimums are met, proceed with other logic
  do {
    // Consider Flex role if its minimum is met (or is 0) and by chance
    if (minimums['flex'] <= counts['flex'] && flexChance() && counts['flex'] < MAX_PLAYERS) {
      role = 'flex';
    } else {
      let eligibleBaseRoles = BASE_ROLES.filter(r => counts[r] < MAX_PLAYERS && minimums[r] <= counts[r]);
      if (eligibleBaseRoles.length === 0) { 
          // If no base roles are eligible (e.g., all at min/max), try flex if it's not at max and its min is met
          if (counts['flex'] < MAX_PLAYERS && minimums['flex'] <= counts['flex']) {
            role = 'flex';
          } else {
            // Fallback: if even flex is not an option, pick any available base role not at MAX_PLAYERS
            // This case should be rare if minimums are set reasonably (not exceeding MAX_PLAYERS)
            let fallbackRoles = BASE_ROLES.filter(r => counts[r] < MAX_PLAYERS);
            if (fallbackRoles.length > 0) role = fallbackRoles[rng(0, fallbackRoles.length-1)];
            else role = 'flex'; // Absolute fallback if all base roles somehow hit MAX_PLAYERS
          }
      } else {
          role = eligibleBaseRoles[rng(0, eligibleBaseRoles.length - 1)];
      }
    }

    // Streak prevention
    if (role === last && streak >= 2) {
      if (Math.random() < 0.7) continue; // 70% chance to reroll if on a 2+ streak of same role
    }
    
    // Ensure we don't exceed overall player count for a role if it had a hard cap (currently just MAX_PLAYERS)
    // This is mostly covered by the initial filter for eligibleBaseRoles and flex check.

    break; // Found a suitable role
  } while (++tries < 50); // Increased tries for more complex logic

  return role;
}
function applyRole(li,role){
  const iconImg = li.querySelector('.role-icon');
  const roleSpan = li.querySelector('.role-name'); 
  const heroSpan = li.querySelector('.suggested-hero');

  // Remove any existing role overlay classes
  ROLE_OVERLAY_CLASSES.forEach(cls => li.classList.remove(cls));

  if (role) {
    iconImg.src = ICONS[role];
    iconImg.style.display = 'inline-block';
    roleSpan.textContent=role.charAt(0).toUpperCase()+role.slice(1);

    // Add new overlay class
    if (role === 'strategist') li.classList.add('role-overlay-strategist');
    else if (role === 'vanguard') li.classList.add('role-overlay-vanguard');
    else if (role === 'duellist') li.classList.add('role-overlay-duellist');
    else if (role === 'flex') li.classList.add('role-overlay-flex');

    if (BASE_ROLES.includes(role)) {
      const heroList = HEROES_BY_ROLE[role.charAt(0).toUpperCase() + role.slice(1)];
      if (heroList && heroList.length > 0) {
        const randomHero = heroList[rng(0, heroList.length - 1)];
        heroSpan.textContent = `${randomHero}`;
      } else {
        heroSpan.textContent = 'No heroes listed';
      }
    } else {
      heroSpan.textContent = '';
    }
  } else { // No role or cleared role
    iconImg.src = '';
    iconImg.style.display = 'none';
    roleSpan.textContent = 'No Role';
    heroSpan.textContent = '';
    // Overlay classes already cleared
  }

  const last=li.dataset.lastRole;
  li.dataset.streak=(role===last?parseInt(li.dataset.streak||'0',10)+1:1);
  li.dataset.lastRole=role;
}
function singleRoll(li){
  const counts=currentCounts();
  counts[li.dataset.lastRole]--;
  let newRole;
  let tries = 0;
  const minimums = { 
    vanguard: parseInt(vanguardMinInput.value) || 0, 
    duellist: parseInt(duellistMinInput.value) || 0, 
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  do {
    newRole = weightedDifferentRole(li, counts, minimums);
    tries++;
  } while (newRole === li.dataset.lastRole && tries < 40);
  applyRole(li, newRole);
  if (autoSortCB.checked) {
    sortPlayers(li, true); // Pass rolled LI and true to animate
  }
  // Add player name to quick list if not empty
  const playerNameInput = li.querySelector('.player-name');
  if (playerNameInput && playerNameInput.value.trim() !== '') {
    addNameToQuickList(playerNameInput.value.trim());
  }
}
function rollAll(){
  const players=[...list.children].filter(li => li.dataset.active === 'true'); // Only roll active players
  if (players.length === 0) return; // No active players to roll
  const counts={vanguard:0,duellist:0,strategist:0,flex:0};
  const minimums = { 
    vanguard: parseInt(vanguardMinInput.value) || 0, 
    duellist: parseInt(duellistMinInput.value) || 0, 
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };

  let playersToAssign = [...players];
  let assignedCounts = {vanguard:0,duellist:0,strategist:0,flex:0};

  playersToAssign.forEach(pLi => {
      const role = weightedDifferentRole(pLi, assignedCounts, minimums);
      applyRole(pLi, role);
      assignedCounts[role]++;
      // Add player name to quick list if not empty
      const playerNameInput = pLi.querySelector('.player-name');
      if (playerNameInput && playerNameInput.value.trim() !== '') {
        addNameToQuickList(playerNameInput.value.trim());
      }
  });
  
  if (autoSortCB.checked) { 
    sortPlayers(null, ANIMATE_ROLL_ALL_SORT); // Pass null and config for animation
  }
}
function capture(){
  const players = [...list.children];
  if(players.length === 0) {
    alert('No players to copy!');
    return;
  }
  let text = 'Marvel Rivals Roles:';
  players.forEach(li => {
    const name = li.querySelector('input').value.trim() || 'Player';
    const role = li.querySelector('.role-name').textContent;
    const suggestedHero = li.querySelector('.suggested-hero').textContent.trim();
    text += `\n${name}: ${role}${suggestedHero ? ' ' + suggestedHero : ''}`;
  });
  navigator.clipboard.writeText(text).then(() => {
    alert('Player roles copied to clipboard!');
  }, () => {
    alert('Failed to copy to clipboard.');
  });
}

// Function to sort players by role (Vanguard, Duellist, Strategist, Flex)
function sortPlayers(rolledLiElement = null, animateThisSort = true) {
  if (!autoSortCB.checked) { // If auto-sort is off, just do a simple sort and return
    const players = [...list.children];
    const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
    players.sort((a, b) => {
      const roleA = a.dataset.lastRole.toLowerCase();
      const roleB = b.dataset.lastRole.toLowerCase();
      const indexA = roleOrder.indexOf(roleA);
      const indexB = roleOrder.indexOf(roleB);
      if (indexA === -1 && indexB === -1) return 0;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    players.forEach(player => list.appendChild(player));
    return;
  }

  if (!animateThisSort) { // If this specific sort call shouldn't be animated (e.g. Roll All with config off)
    const players = [...list.children];
    const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
    players.sort((a, b) => {
      const roleA = a.dataset.lastRole.toLowerCase();
      const roleB = b.dataset.lastRole.toLowerCase();
      const indexA = roleOrder.indexOf(roleA);
      const indexB = roleOrder.indexOf(roleB);
      if (indexA === -1 && indexB === -1) return 0;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    players.forEach(player => list.appendChild(player));
    return;
  }

  const playersLiElements = [...list.children];
  const oldPositions = new Map();

  // 1. First: Record initial positions (offsetTop relative to the list)
  playersLiElements.forEach(li => {
    oldPositions.set(li, li.offsetTop);
  });

  // --- Actual Sorting (JS array sort) ---
  const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
  const originalRolledIndex = rolledLiElement ? playersLiElements.indexOf(rolledLiElement) : -1;

  const sortedPlayerLiElements = [...playersLiElements].sort((a, b) => {
    const roleA = a.dataset.lastRole.toLowerCase();
    const roleB = b.dataset.lastRole.toLowerCase();
    const indexA = roleOrder.indexOf(roleA);
    const indexB = roleOrder.indexOf(roleB);
    if (indexA === -1 && indexB === -1) return 0;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });

  // --- Update DOM Order ---
  sortedPlayerLiElements.forEach(li => list.appendChild(li));

  const newRolledIndex = rolledLiElement ? sortedPlayerLiElements.indexOf(rolledLiElement) : -1;
  const rolledCardMoved = originalRolledIndex !== -1 && newRolledIndex !== -1 && originalRolledIndex !== newRolledIndex;

  // Apply a temporary highlight to the rolled card, regardless of movement for single rolls
  if (rolledLiElement && animateThisSort) { // animateThisSort is true for single rolls
    rolledLiElement.classList.add('rolled-highlight');
    setTimeout(() => {
      rolledLiElement.classList.remove('rolled-highlight');
    }, 700); // Highlight duration
  }

  // --- Invert & Play ---
  sortedPlayerLiElements.forEach(li => {
    const oldTop = oldPositions.get(li);
    if (typeof oldTop !== 'number') return; 

    const newTop = li.offsetTop;
    const deltaY = oldTop - newTop;

    li.style.transition = 'none'; // Disable transitions for the setup
    let transformStyle = `translateY(${deltaY}px)`;

    if (li === rolledLiElement && rolledCardMoved) { // Only scale and elevate if it actually moved
      li.style.zIndex = '10';
      transformStyle += ' scale(1.05)';
    }
    li.style.transform = transformStyle;
  });

  // Force reflow to apply the transform styles before starting the animation
  void list.offsetWidth;

  // Play: Transition to new positions
  sortedPlayerLiElements.forEach(li => {
    li.style.transition = 'transform 0.5s ease-in-out';
    if (li === rolledLiElement && rolledCardMoved) { // Ensure z-index also transitions if it was changed
      li.style.transition = 'transform 0.5s ease-in-out, z-index 0s linear 0.5s';
    }
    li.style.transform = 'translateY(0px) scale(1)';

    li.addEventListener('transitionend', function handler() {
      li.style.transition = '';
      if (li === rolledLiElement && rolledCardMoved) { // Only reset zIndex if it was set
        li.style.zIndex = '';
      }
      // Keep transform at scale(1) translateY(0) - it's the natural state now
      li.removeEventListener('transitionend', handler);
    }, { once: true });
  });
}

// Initialize the application after DOM is loaded and heroes are fetched
document.addEventListener('DOMContentLoaded', async () => {
  await loadHeroes(); // Wait for heroes to load

  // Default to dark mode
  document.body.classList.add('dark-mode');

  const playerPanel = document.querySelector('.player-panel'); // Get player panel
  const quickRow = document.querySelector('.quick-populate-row'); // Get existing quick-row

  // Move quickRow into playerPanel if both exist
  if (playerPanel && quickRow) {
    playerPanel.appendChild(quickRow);
  }

  addBtn.addEventListener('click',addPlayer);
  rollAllBtn.addEventListener('click',rollAll);
  captureBtn.addEventListener('click',capture);
  darkBtn.addEventListener('click',()=>document.body.classList.toggle('dark-mode'));

  // Add event listeners for minimum input validation
  [vanguardMinInput, duellistMinInput, strategistMinInput, flexMinInput].forEach(input => {
    input.addEventListener('input', () => validateAndAdjustMinimums(input));
  });

  // Add event listeners for the min adjustment buttons
  document.querySelectorAll('.min-adjust-btn').forEach(button => {
    button.addEventListener('click', () => {
      const input = button.closest('.option-group').querySelector('input[type="number"]');
      const direction = button.dataset.direction;
      const currentValue = parseInt(input.value) || 0;
      const step = parseInt(input.step) || 1; // Get step from input, default to 1
      const minValue = parseInt(input.min) || 0; // Get min from input, default to 0
      const maxValue = parseInt(input.max) || 6; // Get max from input, default to 6 (or MAX_PLAYERS if applicable? using 6 for now)

      let newValue;
      if (direction === 'increment') {
        newValue = currentValue + step;
      } else {
        newValue = currentValue - step;
      }

      // Check individual min/max bounds first
      if (newValue >= minValue && newValue <= maxValue) {
        // If incrementing, check sum constraint before applying
        if (direction === 'increment') {
            const currentMinimumsSum = parseInt(vanguardMinInput.value || 0) + parseInt(duellistMinInput.value || 0) + parseInt(strategistMinInput.value || 0) + parseInt(flexMinInput.value || 0);
            const proposedSum = currentMinimumsSum - currentValue + newValue; // Subtract old value, add new
            if (proposedSum > MAX_PLAYERS) { // Use MAX_PLAYERS (6) for sum limit
              displayTemporaryMessage(`Sum of minimums cannot exceed ${MAX_PLAYERS}.`);
              return; // Don't update if sum exceeds limit
            }
        }
        
        input.value = newValue;
        // Trigger the input event programmatically to run validateAndAdjustMinimums and updateQuickPopButtons
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
  });

  addPlayer(); // Start with one empty player slot

  // Function to update the state of quick populate buttons
  updateQuickPopButtons(); // Initial call after players are added

  // Quick populate buttons setup
  // const quickRow = document.querySelector('.quick-populate-row'); // Already selected

  // New: Edit Names button - ensure it's appended to playerPanel after quickRow
  if (playerPanel && quickRow) { // Check if playerPanel and quickRow exist
    const editNamesBtn = document.createElement('button');
    editNamesBtn.textContent = 'Edit Names';
    editNamesBtn.className = 'edit-names-btn';
    // quickRow.parentNode.insertBefore(editNamesBtn, quickRow.nextSibling); // Old insertion
    playerPanel.appendChild(editNamesBtn); // Append to playerPanel
    let isEditMode = false;

    editNamesBtn.addEventListener('click', () => {
      isEditMode = !isEditMode;
      renderQuickPopulateButtons(isEditMode);
      editNamesBtn.textContent = isEditMode ? 'Done Editing' : 'Edit Names';
    });
  }

  renderQuickPopulateButtons(); // Initial render from localStorage

  // Function to update the state of quick populate buttons
  updateQuickPopButtons();
});

const QUICK_NAMES_STORAGE_KEY = 'rivalsRollerQuickNames';

function getQuickNames() {
  const storedNames = localStorage.getItem(QUICK_NAMES_STORAGE_KEY);
  return storedNames ? JSON.parse(storedNames) : [];
}

function saveQuickNames(namesArray) {
  localStorage.setItem(QUICK_NAMES_STORAGE_KEY, JSON.stringify(namesArray));
}

function addNameToQuickList(name) {
  if (!name || name.trim() === '') return;
  const currentNames = getQuickNames();
  const trimmedName = name.trim();
  if (!currentNames.includes(trimmedName)) {
    currentNames.push(trimmedName);
    saveQuickNames(currentNames);
    if (document.body.contains(document.querySelector('.edit-names-btn'))) { // Re-render only if UI is present
        renderQuickPopulateButtons(document.querySelector('.edit-names-btn').textContent === 'Done Editing');
    }
  }
}

function renderQuickPopulateButtons(editMode = false) {
  const quickRow = document.querySelector('.quick-populate-row');
  if (!quickRow) return;
  quickRow.innerHTML = ''; // Clear existing buttons
  const names = getQuickNames();

  names.forEach(name => {
    const btnContainer = document.createElement('div');
    btnContainer.className = 'quick-pop-btn-container';
    if (editMode) {
        btnContainer.classList.add('edit-mode');
    }

    const btn = document.createElement('button');
    btn.textContent = name;
    btn.className = 'quick-pop-btn';
    if (editMode) {
        btn.classList.add('edit-mode');
    }
    
    btn.addEventListener('click', () => {
      if (editMode) return; // Don't populate if in edit mode

      let playerInputs = [...list.querySelectorAll('input.player-name')];
      let filled = false;
      for (let inp of playerInputs) {
        if (!inp.value.trim()) {
          inp.value = name;
          updateQuickPopButtons(); // Update used state
          updateAllPlayerStates(); // <<< ADDED THIS CALL
          filled = true;
          break;
        }
      }
      if (!filled && list.children.length < MAX_PLAYERS) {
        addPlayer(); // This will call updateAllPlayerStates internally at its end
        let newInput = list.lastChild.querySelector('input.player-name');
        if (newInput) {
            newInput.value = name;
            updateQuickPopButtons(); // Update used state
            updateAllPlayerStates(); // <<< ADDED THIS CALL (for the case where a new player is added and named)
        }
      }
    });

    btnContainer.appendChild(btn);

    if (editMode) {
      const removeIcon = document.createElement('span');
      removeIcon.className = 'remove-name-icon';
      removeIcon.innerHTML = '&times;'; // Use &times; for a nice X icon
      removeIcon.title = 'Remove this name';
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent button click when removing
        const namesToKeep = getQuickNames().filter(n => n !== name);
        saveQuickNames(namesToKeep);
        renderQuickPopulateButtons(true); // Re-render in edit mode
      });
      btnContainer.appendChild(removeIcon);
    }
    quickRow.appendChild(btnContainer);
  });
  updateQuickPopButtons(); // Update used state for all buttons
}

// Function to update the state of quick populate buttons
function updateQuickPopButtons() {
  const playerNames = [...list.querySelectorAll('input')].map(input => input.value.trim()).filter(name => name !== '');
  const quickPopButtons = document.querySelectorAll('.quick-pop-btn');

  quickPopButtons.forEach(button => {
    const name = button.textContent;
    if (playerNames.includes(name)) {
      button.classList.add('used');
      button.disabled = true; // Disable the button functionality
    } else {
      button.classList.remove('used');
      button.disabled = false; // Enable the button functionality
    }
  });
}

// New function to update active states and auto-add player
function updateAllPlayerStates() {
  const players = [...list.children];
  let allActive = true;
  let activePlayerCount = 0;

  players.forEach(li => {
    const nameInput = li.querySelector('.player-name');
    const rollButton = li.querySelector('.roll');
    if (nameInput.value.trim() !== '') {
      li.dataset.active = 'true';
      rollButton.disabled = false;
      rollButton.classList.remove('disabled');
      activePlayerCount++;
    } else {
      li.dataset.active = 'false';
      rollButton.disabled = true;
      rollButton.classList.add('disabled');
      allActive = false; // If any is empty, not all are active
    }
  });

  // Auto-add new player if all existing have names and we are below max players
  if (allActive && players.length > 0 && players.length < MAX_PLAYERS) {
    addPlayer();
  }
  updateUI(); // Re-evaluate Add Player button state
}
</script>
<div class="quick-populate-row">
</div>
</body>
</html>
