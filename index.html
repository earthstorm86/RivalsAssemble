<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rivals Assemble</title>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <div class="logo"><img src="images/logo-small.png" alt="Rivals Assemble  " width="237" height="177"></div>
  <div class="main">
    <section class="panel player-panel"><ul id="playerList" class="player-list"></ul></section>
    <div class="right-column-container">
      <div class="roll-all-container">
        <button id="rollAllBtn"><i class="fas fa-dice"></i> Roll All</button>
      </div>
      <section class="panel options-panel">
        <button id="copyPlainTextBtn"><i class="fas fa-copy"></i> Copy Team</button>
        <button id="darkBtn"><i class="fas fa-moon"></i> Dark Mode</button>
        <div class="role-options-section">
          <h3>Minimums</h3>
          <div class="min-inputs-grid">
            <div class="option-group">
              <label for="vanguardMin">Vanguard</label>
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="vanguardMin" value="1" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
            <div class="option-group">
              <label for="duellistMin">Duellist</label>
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="duellistMin" value="2" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
            <div class="option-group">
              <label for="strategistMin">Strategist</label>
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="strategistMin" value="2" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
            <div class="option-group">
              <label for="flexMin">Flex</label>
              <button class="min-adjust-btn" data-direction="decrement">-</button>
              <input type="number" id="flexMin" value="0" min="0" max="6">
              <button class="min-adjust-btn" data-direction="increment">+</button>
            </div>
            <div id="minimumsWarning" class="warning-message"></div>
          </div>
          <label id="lblAutoSort"><input type="checkbox" id="autoSortCB" checked>Auto Sort Roles</label>
          <label id="lblRotateRoles"><input type="checkbox" id="rotateRolesCB" checked>Rotate Roles on Reroll</label>
        </div>
      </section>
    </div>
  </div>
<script>
const ANIMATE_ROLL_ALL_SORT = true; // Config option for animating sort on Roll All
let HEROES_BY_ROLE = {}; // Initialize as empty object

const ROLE_OVERLAY_CLASSES = [
  'role-overlay-strategist',
  'role-overlay-vanguard',
  'role-overlay-duellist',
  'role-overlay-flex'
];

async function loadHeroes() {
  try {
    const response = await fetch('data/heroes.json');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    HEROES_BY_ROLE = await response.json();
    console.log('Heroes loaded:', HEROES_BY_ROLE);
  } catch (error) {
    console.error('Could not load heroes:', error);
    // Optionally, set some default/empty hero lists or alert the user
    HEROES_BY_ROLE = {
      "Strategist": ["Error loading heroes"],
      "Vanguard": ["Error loading heroes"],
      "Duellist": ["Error loading heroes"]
    };
  }
}

const MIN_PLAYERS=2,MAX_PLAYERS=6;
const ICONS={vanguard:'images/VanguardIcon.png',duellist:'images/DuellistIcon.png',strategist:'images/StrategistIcon.png',flex:'images/FlexIcon.png'};
const BASE_ROLES=['vanguard','duellist','strategist'];
const list=document.getElementById('playerList');
const rollAllBtn=document.getElementById('rollAllBtn');
const darkBtn=document.getElementById('darkBtn');
const vanguardMinInput = document.getElementById('vanguardMin');
const duellistMinInput = document.getElementById('duellistMin');
const strategistMinInput = document.getElementById('strategistMin');
const flexMinInput = document.getElementById('flexMin');
const autoSortCB = document.getElementById('autoSortCB');
const rotateRolesCB = document.getElementById('rotateRolesCB');
const rng=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=rng(0,i);[a[i],a[j]]=[a[j],a[i]];}return a;};
const flexChance=()=>Math.random()<0.05;

function addPlayer(){if(list.children.length>=MAX_PLAYERS)return;const li=document.createElement('li');li.className='player-item';li.dataset.active = 'false'; // Initially inactive
li.innerHTML=`
  <button class="remove" title="Remove">×</button>
  <div class="player-name-wrapper">
    <input class="player-name" type="text" placeholder="Name">
    <button class="player-name-dropdown-arrow" title="Show saved names">▼</button>
    <div class="player-name-dropdown-list"></div>
  </div>
  <div class="role-info">
    <img class="role-icon" src="">
    <span class="role-name">No Role</span>
    <span class="suggested-hero"></span>
  </div>
  <button class="roll" title="Roll">
    <svg viewBox="0 0 24 24" width="1em" height="1em">
      <!-- Background rectangle - set fill to black -->
      <rect x="3" y="3" width="18" height="18" rx="3" ry="3" fill="black"/>
      <!-- Dots (positioned for faces 1-6) -->
      <!-- Center dot (for 1, 3, 5) -->
      <circle id="dot-center" cx="12" cy="12" r="2" fill="black"/>
      <!-- Top-left and Bottom-right dots (for 2, 3, 4, 5, 6) -->
      <circle id="dot-tl" cx="7" cy="7" r="2" fill="black"/>
      <circle id="dot-br" cx="17" cy="17" r="2" fill="black"/>
      <!-- Top-right and Bottom-left dots (for 4, 5, 6) -->
      <circle id="dot-tr" cx="17" cy="7" r="2" fill="black"/>
      <circle id="dot-bl" cx="7" cy="17" r="2" fill="black"/>
      <!-- Middle-left and Middle-right dots (for 6) -->
      <circle id="dot-mid-l" cx="7" cy="12" r="2" fill="black"/>
      <circle id="dot-mid-r" cx="17" cy="12" r="2" fill="black"/>
    </svg>
  </button>
`;li.dataset.lastRole='';li.dataset.streak='0';
const playerNameInput = li.querySelector('.player-name');
const dropdownArrow = li.querySelector('.player-name-dropdown-arrow');
const rollButton = li.querySelector('.roll'); // Get roll button

rollButton.disabled = true; // Disable roll button initially

li.querySelector('.remove').addEventListener('click',()=>{li.remove();updateUI();updateQuickPopButtons();updateAllPlayerStates();});
rollButton.addEventListener('click',()=>singleRoll(li));
playerNameInput.addEventListener('input', ()=>{
  updateQuickPopButtons();
  updateAllPlayerStates();
});
dropdownArrow.addEventListener('click', (e) => {
  e.stopPropagation(); 
  toggleNameDropdown(playerNameInput, dropdownArrow);
});

list.append(li);updateUI();updateQuickPopButtons();updateAllPlayerStates();}

// --- Functions for Name Dropdown (moved to global scope) ---
function toggleNameDropdown(inputElement, arrowButton) {
  const wrapper = inputElement.closest('.player-name-wrapper');
  const dropdownList = wrapper.querySelector('.player-name-dropdown-list');
  const isOpen = dropdownList.classList.toggle('open');
  wrapper.classList.toggle('dropdown-active-wrapper', isOpen); // Add/remove class on wrapper

  if (isOpen) {
    // Close other open dropdowns
    document.querySelectorAll('.player-name-dropdown-list.open').forEach(otherDropdown => {
      if (otherDropdown !== dropdownList) {
        otherDropdown.classList.remove('open');
        otherDropdown.closest('.player-name-wrapper').classList.remove('dropdown-active-wrapper');
      }
    });
    renderNameDropdownList(inputElement, dropdownList);
  } else {
    // Ensure the class is removed if closed by toggling itself
    wrapper.classList.remove('dropdown-active-wrapper');
  }
}

function renderNameDropdownList(inputElement, dropdownListContainer) {
  const currentInputValueForThisInput = inputElement.value.trim().toLowerCase();
  const allSavedNames = getQuickNames();

  // Get all names currently used in ANY player input field
  const currentlyUsedNamesInPlayerList = [...list.children]
    .map(li => {
      const nameInput = li.querySelector('.player-name');
      return nameInput ? nameInput.value.trim().toLowerCase() : '';
    })
    .filter(name => name !== '' && name !== currentInputValueForThisInput); // Exclude empty and the current field's own initial value

  const namesToShow = allSavedNames.filter(savedName => {
    const savedNameLower = savedName.toLowerCase();
    // Show if: 
    // 1. It's not the value currently in *this* input field 
    //    (though this is mostly covered by the next check if the current input has a value)
    // AND 2. It's not in the list of names used by *other* player inputs.
    return savedNameLower !== currentInputValueForThisInput && 
           !currentlyUsedNamesInPlayerList.includes(savedNameLower);
  });

  dropdownListContainer.innerHTML = ''; // Clear previous items

  if (namesToShow.length === 0) {
    const noNamesItem = document.createElement('div');
    noNamesItem.textContent = 'No other available names'; // Adjusted message
    noNamesItem.style.padding = '0.6rem 0.8rem';
    noNamesItem.style.color = '#888';
    dropdownListContainer.appendChild(noNamesItem);
    return;
  }

  namesToShow.forEach(name => {
    const item = document.createElement('div');
    item.className = 'player-name-dropdown-item';
    item.textContent = name;
    item.addEventListener('click', () => {
      inputElement.value = name;
      dropdownListContainer.classList.remove('open');
      dropdownListContainer.closest('.player-name-wrapper').classList.remove('dropdown-active-wrapper'); 
      inputElement.dispatchEvent(new Event('input', { bubbles: true })); 
      const playerItemLi = inputElement.closest('.player-item');
      if (playerItemLi && playerItemLi.dataset.active === 'true') singleRoll(playerItemLi);
    });
    dropdownListContainer.appendChild(item);
  });
}

// Global click listener to close dropdowns (moved to global scope)
document.addEventListener('click', (event) => {
  const openDropdowns = document.querySelectorAll('.player-name-dropdown-list.open');
  openDropdowns.forEach(dropdown => {
    const wrapper = dropdown.closest('.player-name-wrapper');
    // Check if the click was outside the dropdown and its associated input wrapper
    if (!wrapper.contains(event.target)) {
      dropdown.classList.remove('open');
      wrapper.classList.remove('dropdown-active-wrapper'); // Remove wrapper class on outside click
    }
  });
});

// --- End Functions for Name Dropdown ---

function currentCounts(){const c={vanguard:0,duellist:0,strategist:0,flex:0};[...list.children].forEach(li=>{const r=li.dataset.lastRole;if(r)c[r]++;});return c;}
function updateUI(){
  const c = list.children.length;
  // const hasEmptySlot = [...list.children].some(item => !item.querySelector('.player-name').value.trim());
  // addBtn related lines removed
  
  list.querySelectorAll('.remove').forEach(b=>{
    b.disabled = c <= MIN_PLAYERS; 
    b.classList.toggle('disabled',b.disabled);
  });
}

// Function to display a temporary message below the minimums heading
function displayTemporaryMessage(message) {
  const warningElement = document.getElementById('minimumsWarning');
  if (warningElement) {
    warningElement.textContent = message;
    warningElement.style.display = 'block'; // Make it visible

    setTimeout(() => {
      warningElement.textContent = '';
      warningElement.style.display = 'none'; // Hide it after 3 seconds
    }, 3000);
  }
}

function validateAndAdjustMinimums(changedInput) {
  const currentMinimums = {
    vanguard: parseInt(vanguardMinInput.value) || 0,
    duellist: parseInt(duellistMinInput.value) || 0,
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  const sumOfMinimums = Object.values(currentMinimums).reduce((sum, val) => sum + val, 0);

  if (sumOfMinimums > 6) {
    const excess = sumOfMinimums - 6;
    let changedInputValue = parseInt(changedInput.value) || 0;
    let newChangedValue = changedInputValue - excess;

    if (newChangedValue < 0) newChangedValue = 0; // Ensure it doesn't go below 0
    changedInput.value = newChangedValue;

    // Display warning message instead of alert
    const roleName = changedInput.id.replace('Min', '');
    displayTemporaryMessage(`Sum of minimums cannot exceed 6. ${roleName.charAt(0).toUpperCase() + roleName.slice(1)} Min has been adjusted.`);
  }

  // After validation/adjustment, check if current assignments meet new minimums
  const finalMinimums = {
    vanguard: parseInt(vanguardMinInput.value) || 0,
    duellist: parseInt(duellistMinInput.value) || 0,
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  const currentRoleCounts = currentCounts(); // Get current actual counts of roles

  let needsReroll = false;
  if (currentRoleCounts.vanguard < finalMinimums.vanguard) needsReroll = true;
  if (currentRoleCounts.duellist < finalMinimums.duellist) needsReroll = true;
  if (currentRoleCounts.strategist < finalMinimums.strategist) needsReroll = true;
  if (currentRoleCounts.flex < finalMinimums.flex) needsReroll = true;
  
  // Log values for debugging
  console.log("--- Min Change Check ---");
  console.log("Final Minimums:", JSON.stringify(finalMinimums));
  console.log("Current Role Counts:", JSON.stringify(currentRoleCounts));
  console.log("Needs Reroll Flag Before Check:", needsReroll);

  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true');
  const sumOfFinalMinimums = Object.values(finalMinimums).reduce((sum, val) => sum + val, 0);

  console.log("Active Players Count:", activePlayers.length);
  console.log("Sum of Final Minimums:", sumOfFinalMinimums);

  // Only reroll if needed AND it's possible to satisfy the sum of minimums with the current player count
  if (needsReroll && activePlayers.length > 0 && activePlayers.length >= sumOfFinalMinimums) {
    displayTemporaryMessage('Minimums changed and are satisfiable, rerolling all players...');
    rollAll();
  } else if (needsReroll && activePlayers.length > 0 && activePlayers.length < sumOfFinalMinimums) {
    displayTemporaryMessage('Minimums changed, but cannot be met with current player count.');
    console.log("Reroll skipped: Not enough active players to meet the sum of new minimums.");
  }
}

function weightedDifferentRole(li, counts, minimums) {
  const lastRole = li.dataset.lastRole;
  const streak = parseInt(li.dataset.streak || '0', 10);
  let newRole;
  let tries = 0;
  const allRolesWithMinimums = [...BASE_ROLES, 'flex'];

  // 1. Check if any role is now below its minimum due to this player's role being removed from 'counts'.
  //    'counts' is the team's role distribution *before* this player gets a new role (i.e., their old role slot is vacant).
  const rolesNeededForMinimums = allRolesWithMinimums.filter(r => counts[r] < minimums[r]);
  if (rolesNeededForMinimums.length > 0) {
    // If player's lastRole is one of the critically needed roles, or if not rotating, prioritize it.
    // Otherwise, pick from any of the needed roles.
    // This ensures minimums are strictly met first.
    shuffle(rolesNeededForMinimums);
    newRole = rolesNeededForMinimums[0]; 
    // Apply streak prevention here if the only way to meet minimums is to repeat the last role.
    if (newRole === lastRole && streak >= 2) {
        if (Math.random() < 0.7 && rolesNeededForMinimums.length === 1 && rolesNeededForMinimums[0] === lastRole) {
            // Highly constrained: only one role fixes minimums, and it's a streak.
            // We are forced to pick it. Or, if there were other options in rolesNeededForMinimums, shuffle might pick a different one.
        } else if (rolesNeededForMinimums.length > 1) {
            // Try to pick a different needed role if lastRole was also needed
            let otherNeededRoles = rolesNeededForMinimums.filter(r => r !== lastRole);
            if (otherNeededRoles.length > 0) {
                shuffle(otherNeededRoles);
                newRole = otherNeededRoles[0];
            }
        }
    }
    applyRole(li, newRole);
    return newRole; // Exit early, minimums dictated the choice.
  }

  // If we are here, all minimums are currently met by the team composition in 'counts'.
  // Now, try to select a role, respecting Rotate Roles preference.
  do {
    tries++;
    let candidateRoles = [];
    allRolesWithMinimums.forEach(r => {
      // A role is a candidate if there's space for it, and its own minimum is currently met by the team.
      if (counts[r] < MAX_PLAYERS && minimums[r] <= counts[r]) {
        candidateRoles.push(r);
      }
    });

    // Always add Flex as a candidate if it has space and its minimum is met (treat like other roles)
    // (No longer using flexChance random gating)
    // if (!candidateRoles.includes('flex') && counts['flex'] < MAX_PLAYERS && minimums['flex'] <= counts['flex']) {
    //   candidateRoles.push('flex');
    // }

    if (candidateRoles.length === 0) {
      // Fallback: if no roles are "open" (e.g. all are exactly at min and no flex space),
      // broaden to any role that simply has space, as global minimums ARE met.
      candidateRoles = allRolesWithMinimums.filter(r => counts[r] < MAX_PLAYERS);
      if (candidateRoles.length === 0) { // All roles are at MAX_PLAYERS
        newRole = lastRole || allRolesWithMinimums[rng(0, allRolesWithMinimums.length - 1)];
        break; // Absolute fallback if team is literally full for all roles.
      }
    }

    let chosenRole;
    if (rotateRolesCB && rotateRolesCB.checked && lastRole && candidateRoles.includes(lastRole)) {
      const alternativeCandidates = candidateRoles.filter(r => r !== lastRole);
      if (alternativeCandidates.length > 0) {
        shuffle(alternativeCandidates);
        chosenRole = alternativeCandidates[0];
      } else {
        // No alternatives, or lastRole wasn't a candidate to begin with (shouldn't happen if .includes was true)
        chosenRole = lastRole; // Must stick if it's the only valid option among candidates
      }
    } else {
      // Rotate not checked, or no lastRole, or lastRole not among current candidates.
      shuffle(candidateRoles);
      chosenRole = candidateRoles[0];
    }
    newRole = chosenRole;

    // Streak Prevention: Applied to the chosen role (which might have been rotated)
    if (newRole === lastRole && streak >= 2) {
      if (Math.random() < 0.7) { // 70% chance to reroll selection process
        if (tries < 50) continue; // Try the whole selection again
      }
    }
    break; // Role selected, or streak prevention attempts exhausted
  } while (tries < 50);

  return newRole || lastRole || allRolesWithMinimums[rng(0, allRolesWithMinimums.length - 1)]; // Final fallback
}
function applyRole(li, newRoleParam, heroName) {
  const iconImg = li.querySelector('.role-icon');
  const roleSpan = li.querySelector('.role-name');
  const heroSpan = li.querySelector('.suggested-hero');

  const previousRoleFull = li.dataset.lastRole; // e.g., "Vanguard" or ""
  const previousRoleNormalized = previousRoleFull ? previousRoleFull.toLowerCase() : null; // e.g., "vanguard" or null

  const newRoleFull = newRoleParam; // e.g., "Duellist" or null
  const newRoleNormalized = newRoleFull ? newRoleFull.toLowerCase() : null; // e.g., "duellist" or null

  // --- Update CSS Classes for background/overlay ---
  if (newRoleNormalized !== previousRoleNormalized) {
    const prevOverlayClass = previousRoleNormalized ? `role-overlay-${previousRoleNormalized}` : null;
    const newOverlayClass = newRoleNormalized ? `role-overlay-${newRoleNormalized}` : null;

    if (prevOverlayClass && newOverlayClass) {
      li.classList.replace(prevOverlayClass, newOverlayClass);
    } else if (newOverlayClass) {
      li.classList.add(newOverlayClass);
    } else if (prevOverlayClass) {
      li.classList.remove(prevOverlayClass);
    }
  }

  // --- Update UI elements (icon, text) ---
  if (newRoleFull) {
    iconImg.src = ICONS[newRoleNormalized];
    iconImg.style.display = 'inline-block';
    roleSpan.textContent = newRoleFull.charAt(0).toUpperCase() + newRoleFull.slice(1);
    if (BASE_ROLES.includes(newRoleNormalized)) {
      heroSpan.textContent = heroName || '';
    } else {
      heroSpan.textContent = '';
    }
  } else {
    iconImg.src = '';
    iconImg.style.display = 'none';
    roleSpan.textContent = 'No Role';
    heroSpan.textContent = '';
  }

  // --- Update streak and lastRole dataset ---
  li.dataset.streak = (newRoleFull === previousRoleFull ? parseInt(li.dataset.streak || '0', 10) + 1 : 1);
  li.dataset.lastRole = newRoleFull || '';
}

// New Helper Function to get a unique hero if possible
function getUniqueHero(role, assignedHeroesForThisRoleContext, heroesData) {
  const roleKey = role.charAt(0).toUpperCase() + role.slice(1);
  const availableHeroes = heroesData[roleKey];

  if (!availableHeroes || availableHeroes.length === 0) {
    return 'No heroes listed'; // Or empty string: ''
  }

  // Find heroes not yet assigned in the current context (e.g., current rollAll session, or other players for singleRoll)
  let unassignedHeroes = availableHeroes.filter(hero => !assignedHeroesForThisRoleContext.includes(hero));

  if (unassignedHeroes.length > 0) {
    return unassignedHeroes[rng(0, unassignedHeroes.length - 1)];
  } else {
    // All heroes for this role are already assigned in this context, so we have to pick a duplicate
    return availableHeroes[rng(0, availableHeroes.length - 1)];
  }
}

// New function to update dice dots based on player index
function updateDiceDots() {
  const players = [...list.children];
  players.forEach((li, index) => {
    const diceFace = index + 1; // Player 1 is index 0, corresponds to dice face 1
    const svg = li.querySelector('.roll svg');
    if (!svg) return;

    // Hide all dots initially
    svg.querySelectorAll('circle').forEach(circle => circle.style.display = 'none');

    // Show dots based on dice face number (player index + 1)
    switch (diceFace) {
      case 1:
        svg.querySelector('#dot-center').style.display = 'inline';
        break;
      case 2:
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 3:
        svg.querySelector('#dot-center').style.display = 'inline';
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 4:
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-tr').style.display = 'inline';
        svg.querySelector('#dot-bl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 5:
        svg.querySelector('#dot-center').style.display = 'inline';
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-tr').style.display = 'inline';
        svg.querySelector('#dot-bl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        break;
      case 6:
        svg.querySelector('#dot-tl').style.display = 'inline';
        svg.querySelector('#dot-tr').style.display = 'inline';
        svg.querySelector('#dot-bl').style.display = 'inline';
        svg.querySelector('#dot-br').style.display = 'inline';
        svg.querySelector('#dot-mid-l').style.display = 'inline';
        svg.querySelector('#dot-mid-r').style.display = 'inline';
        break;
      default:
        // For indices > 5 or other cases, show no dots
        break;
    }
  });
}

function singleRoll(li){
  const counts = currentCounts();
  if (li.dataset.lastRole) { // Check if lastRole exists before decrementing
    counts[li.dataset.lastRole]--;
  }

  let newRole;
  let tries = 0;
  const minimums = { 
    vanguard: parseInt(vanguardMinInput.value) || 0, 
    duellist: parseInt(duellistMinInput.value) || 0, 
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };
  do {
    newRole = weightedDifferentRole(li, counts, minimums);
    tries++;
  } while (newRole === li.dataset.lastRole && tries < 40 && BASE_ROLES.includes(newRole)); // Added BASE_ROLES check to ensure flex can repeat if needed

  let chosenHeroName = '';
  if (BASE_ROLES.includes(newRole)) {
    const assignedHeroesForThisRole = [...list.children]
      .filter(otherLi => otherLi !== li && otherLi.dataset.lastRole === newRole)
      .map(otherLiWithSameRole => otherLiWithSameRole.querySelector('.suggested-hero').textContent)
      .filter(Boolean); // Filter out empty strings
    chosenHeroName = getUniqueHero(newRole, assignedHeroesForThisRole, HEROES_BY_ROLE);
  }

  applyRole(li, newRole, chosenHeroName);
  if (autoSortCB.checked) {
    sortPlayers(li, true); // Pass rolled LI and true to animate
  }
  // Add player name to quick list if not empty
  const playerNameInput = li.querySelector('.player-name');
  if (playerNameInput && playerNameInput.value.trim() !== '') {
    addNameToQuickList(playerNameInput.value.trim());
  }
  updateDiceDots(); // Update dice dots after a single roll (in case sort changes index)
}
function rollAll(){
  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true');
  if (activePlayers.length === 0) return; 

  // Save the current team names before rolling
  const currentTeamNames = activePlayers.map(li => li.querySelector('.player-name').value.trim()).filter(name => name !== '');
  if (currentTeamNames.length > 0) {
    localStorage.setItem(LAST_ROLL_ALL_TEAM_KEY, JSON.stringify(currentTeamNames));
  }

  const assignedCounts = {vanguard:0, duellist:0, strategist:0, flex:0};
  const minimums = { 
    vanguard: parseInt(vanguardMinInput.value) || 0, 
    duellist: parseInt(duellistMinInput.value) || 0, 
    strategist: parseInt(strategistMinInput.value) || 0,
    flex: parseInt(flexMinInput.value) || 0
  };

  // Keep track of heroes assigned in this "roll all" session for each role
  const assignedHeroesByRoleThisSession = {vanguard: [], duellist: [], strategist: []}; // Flex heroes are not tracked for uniqueness this way

  let playersToAssign = [...activePlayers];

  playersToAssign.forEach(pLi => {
      const role = weightedDifferentRole(pLi, assignedCounts, minimums);
      let chosenHeroName = '';
      if (BASE_ROLES.includes(role)) {
        chosenHeroName = getUniqueHero(role, assignedHeroesByRoleThisSession[role] || [], HEROES_BY_ROLE);
        if (!assignedHeroesByRoleThisSession[role]) {
          assignedHeroesByRoleThisSession[role] = [];
        }
        if (chosenHeroName && chosenHeroName !== 'No heroes listed') { // Only add if a valid hero was picked
            assignedHeroesByRoleThisSession[role].push(chosenHeroName);
        }
      }
      applyRole(pLi, role, chosenHeroName);
      assignedCounts[role]++;
      // Add player name to quick list if not empty
      const playerNameInput = pLi.querySelector('.player-name');
      if (playerNameInput && playerNameInput.value.trim() !== '') {
        addNameToQuickList(playerNameInput.value.trim());
      }
  });
  
  if (autoSortCB.checked) { 
    sortPlayers(null, ANIMATE_ROLL_ALL_SORT); // Pass null and config for animation
  }
  updateDiceDots(); // Update dice dots after roll all (order might change if sorted)
}
function copyPlayersPlainText(){
  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true' && li.querySelector('.player-name').value.trim() !== '');
  if(activePlayers.length === 0) {
    displayTemporaryMessage('No active players with names to copy!');
    return;
  }
  let text = 'Marvel Rivals Roles:';
  activePlayers.forEach(li => {
    const name = li.querySelector('.player-name').value.trim(); // Use .player-name input
    const role = li.querySelector('.role-name').textContent;
    const suggestedHero = li.querySelector('.suggested-hero').textContent.trim();
    text += `\n${name}: ${role}${suggestedHero ? ' (' + suggestedHero + ')' : ''}`; // Added parenthesis for suggested hero
  });
  navigator.clipboard.writeText(text).then(() => {
    displayTemporaryMessage('Player roles (plain text) copied!');
  }, () => {
    displayTemporaryMessage('Failed to copy plain text.');
  });
}

function copyPlayersTSV() {
  const activePlayers = [...list.children].filter(li => li.dataset.active === 'true' && li.querySelector('.player-name').value.trim() !== '');
  if (activePlayers.length === 0) {
    displayTemporaryMessage('No active players with names to copy for TSV!');
    return;
  }

  let tsvString = "Player Name\tRole\tSuggested Hero\n"; // Header row

  activePlayers.forEach(li => {
    const nameInput = li.querySelector('.player-name');
    const name = nameInput ? nameInput.value.trim() : 'Unnamed Player';
    const role = li.querySelector('.role-name').textContent.trim();
    const suggestedHero = li.querySelector('.suggested-hero').textContent.trim();
    
    tsvString += `${name}\t${role}\t${suggestedHero}\n`;
  });

  navigator.clipboard.writeText(tsvString.trim()).then(() => {
    displayTemporaryMessage('Player data copied to clipboard (TSV)!');
  }, (err) => {
    displayTemporaryMessage('Failed to copy TSV to clipboard.');
    console.error('TSV Copy Error:', err);
  });
}


// Function to sort players by role (Vanguard, Duellist, Strategist, Flex)
function sortPlayers(rolledLiElement = null, animateThisSort = true) {
  if (!autoSortCB.checked) {
    const players = [...list.children];
    const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
    players.sort((a, b) => {
      const roleA = a.dataset.lastRole.toLowerCase();
      const roleB = b.dataset.lastRole.toLowerCase();
      const indexA = roleOrder.indexOf(roleA);
      const indexB = roleOrder.indexOf(roleB);
      if (indexA === -1 && indexB === -1) return 0;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    players.forEach(player => list.appendChild(player));
    updateDiceDots();
    return;
  }

  if (!animateThisSort) {
    const players = [...list.children];
    const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
    players.sort((a, b) => {
      const roleA = a.dataset.lastRole.toLowerCase();
      const roleB = b.dataset.lastRole.toLowerCase();
      const indexA = roleOrder.indexOf(roleA);
      const indexB = roleOrder.indexOf(roleB);
      if (indexA === -1 && indexB === -1) return 0;
      if (indexA === -1) return 1;
      if (indexB === -1) return -1;
      return indexA - indexB;
    });
    players.forEach(player => list.appendChild(player));
    updateDiceDots();
    return;
  }

  const playersLiElements = [...list.children];
  const oldPositions = new Map();

  playersLiElements.forEach(li => {
    oldPositions.set(li, li.offsetTop);
  });

  const roleOrder = ['vanguard', 'duellist', 'strategist', 'flex', ''];
  const originalRolledIndex = rolledLiElement ? playersLiElements.indexOf(rolledLiElement) : -1;

  const sortedPlayerLiElements = [...playersLiElements].sort((a, b) => {
    const roleA = a.dataset.lastRole.toLowerCase();
    const roleB = b.dataset.lastRole.toLowerCase();
    const indexA = roleOrder.indexOf(roleA);
    const indexB = roleOrder.indexOf(roleB);
    if (indexA === -1 && indexB === -1) return 0;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });

  sortedPlayerLiElements.forEach(li => list.appendChild(li));
  updateDiceDots();

  const newRolledIndex = rolledLiElement ? sortedPlayerLiElements.indexOf(rolledLiElement) : -1;
  const rolledCardMoved = originalRolledIndex !== -1 && newRolledIndex !== -1 && originalRolledIndex !== newRolledIndex;

  if (rolledLiElement && animateThisSort) {
    rolledLiElement.classList.add('rolled-highlight');
    setTimeout(() => {
      rolledLiElement.classList.remove('rolled-highlight');
    }, 700);
  }

  sortedPlayerLiElements.forEach(itemLi => {
    const oldTop = oldPositions.get(itemLi);
    if (typeof oldTop !== 'number') return;
    const newTop = itemLi.offsetTop;
    const deltaY = oldTop - newTop;

    itemLi.style.transition = 'none';
    let transformStyle = `translateY(${deltaY}px)`;

    if (itemLi === rolledLiElement && rolledCardMoved) {
      itemLi.style.zIndex = '10';
      transformStyle += ' scale(1.05)';
    }
    itemLi.style.transform = transformStyle;
  });

  void list.offsetWidth;

  sortedPlayerLiElements.forEach(itemLi => {
    let transitions = ['transform 0.5s ease-in-out'];
    if (itemLi === rolledLiElement && rolledCardMoved) {
        transitions.push('z-index 0s linear 0.5s');
    }
    itemLi.style.transition = transitions.join(', ');
    itemLi.style.transform = 'translateY(0px) scale(1)';

    itemLi.addEventListener('transitionend', function handler(event) {
      if (event.propertyName === 'transform') { // Only act on transform transition end
        itemLi.style.transition = '';
        if (itemLi === rolledLiElement && rolledCardMoved) {
          itemLi.style.zIndex = '';
        }
        itemLi.style.transform = 'none';
        itemLi.removeEventListener('transitionend', handler);
      }
    }, { once: true }); // {once: true} is fine if we only care about transform
  });
}

// Function to update the text of the dark mode button
function updateDarkModeButtonText() {
  const isDarkMode = document.body.classList.contains('dark-mode');
  if (isDarkMode) {
    darkBtn.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
  } else {
    darkBtn.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
  }
}

// Initialize the application after DOM is loaded and heroes are fetched
document.addEventListener('DOMContentLoaded', async () => {
  await loadHeroes(); 
  document.body.classList.add('dark-mode');
  updateDarkModeButtonText(); 

  const playerPanel = document.querySelector('.player-panel'); 
  const quickPopRow = document.querySelector('.quick-populate-row'); 
  if (playerPanel && quickPopRow) {
    playerPanel.appendChild(quickPopRow);
    const editNamesButton = document.createElement('button');
    editNamesButton.textContent = 'Edit Names';
    editNamesButton.className = 'edit-names-btn';
    playerPanel.appendChild(editNamesButton); 
    let isEditMode = false;
    editNamesButton.addEventListener('click', () => {
      isEditMode = !isEditMode;
      renderQuickPopulateButtons(isEditMode);
      editNamesButton.textContent = isEditMode ? 'Done Editing' : 'Edit Names';
    });
  }

  rollAllBtn.addEventListener('click',rollAll);
  document.getElementById('copyPlainTextBtn').addEventListener('click', copyPlayersPlainText);
  darkBtn.addEventListener('click',()=>{
    document.body.classList.toggle('dark-mode');
    updateDarkModeButtonText(); 
  });

  [vanguardMinInput, duellistMinInput, strategistMinInput, flexMinInput].forEach(input => {
    input.addEventListener('input', () => validateAndAdjustMinimums(input));
  });

  document.querySelectorAll('.min-adjust-btn').forEach(button => {
    button.addEventListener('click', () => {
      const input = button.closest('.option-group').querySelector('input[type="number"]');
      const direction = button.dataset.direction;
      const currentValue = parseInt(input.value) || 0;
      const step = parseInt(input.step) || 1; 
      const minValue = parseInt(input.min) || 0; 
      const maxValue = parseInt(input.max) || 6; 
      let newValue;
      if (direction === 'increment') newValue = currentValue + step;
      else newValue = currentValue - step;
      if (newValue >= minValue && newValue <= maxValue) {
        if (direction === 'increment') {
            const currentMinimumsSum = parseInt(vanguardMinInput.value || 0) + parseInt(duellistMinInput.value || 0) + parseInt(strategistMinInput.value || 0) + parseInt(flexMinInput.value || 0);
            const proposedSum = currentMinimumsSum - currentValue + newValue; 
            if (proposedSum > MAX_PLAYERS) { 
              displayTemporaryMessage(`Sum of minimums cannot exceed ${MAX_PLAYERS}.`);
              return; 
            }
        }
        input.value = newValue;
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
  });

  // Pre-populate with the last roll all team
  const lastTeam = JSON.parse(localStorage.getItem(LAST_ROLL_ALL_TEAM_KEY) || '[]');
  let prePopulated = false;
  if (lastTeam && lastTeam.length > 0) {
    // Clear any existing empty player slots first
    while (list.children.length > 0) {
        list.removeChild(list.lastChild);
    }
    for (let i = 0; i < lastTeam.length; i++) {
        if (list.children.length < MAX_PLAYERS) {
            addPlayer(); // Adds a new inactive player slot
            const newPlayerItem = list.lastChild;
            if (newPlayerItem) {
                const nameInput = newPlayerItem.querySelector('.player-name');
                nameInput.value = lastTeam[i];
                // No need to dispatch input event here, updateAllPlayerStates will handle it
            }
        }
    }
    prePopulated = true;
  }

  // If no team was loaded from local storage, add initial MIN_PLAYERS slots
  if (!prePopulated) {
    for(let i=0;i<MIN_PLAYERS;i++) addPlayer();
  }

  updateAllPlayerStates(); // This will set initial active states and add new slot if needed
  updateUI();
  updateQuickPopButtons();
  updateDarkModeButtonText(); // Set initial button text

  if (prePopulated && list.children.length > 0) {
    rollAll(); // Automatically roll all if team was pre-populated
  }

  // Initialize MutationObserver
  const observer = new MutationObserver((mutationsList, observer) => {
    for(const mutation of mutationsList) {
        if (mutation.type === 'childList') {
            // When children are added or removed from the list
            [...list.children].forEach((playerItem, index) => {
                updateDiceDots(playerItem, index + 1);
            });
        }
    }
  });
  observer.observe(list, { childList: true });

  // Initial dice dot update for any players added by default
  [...list.children].forEach((playerItem, index) => {
    updateDiceDots(playerItem, index + 1);
  });
});

const QUICK_NAMES_STORAGE_KEY = 'rivalsRollerQuickNames';
const LAST_ROLL_ALL_TEAM_KEY = 'rivalsRollerLastTeam'; // Ensure this key is defined

function getQuickNames() {
  const storedNames = localStorage.getItem(QUICK_NAMES_STORAGE_KEY);
  try {
    const parsed = JSON.parse(storedNames);
    if (Array.isArray(parsed)) {
      // Ensure all items are strings and not empty after trimming
      return parsed.map(item => String(item).trim()).filter(item => item !== '');
    }
    return [];
  } catch (e) {
    return [];
  }
}

function saveQuickNames(namesArray) {
  // Ensure only unique, non-empty, trimmed strings are saved
  const uniqueNames = [...new Set(namesArray.map(name => String(name).trim()).filter(name => name !== ''))];
  localStorage.setItem(QUICK_NAMES_STORAGE_KEY, JSON.stringify(uniqueNames));
}

function addNameToQuickList(name) { // Updates simple array of strings
  if (!name || name.trim() === '') return;
  const currentNames = getQuickNames();
  const trimmedName = name.trim();
  if (!currentNames.includes(trimmedName)) {
    currentNames.push(trimmedName);
    saveQuickNames(currentNames);
  }
  // No need to re-render quick-pop buttons here directly as addPlayer/input events will handle it.
  // The original renderQuickPopulateButtons sorting by name is fine.
}

function renderQuickPopulateButtons(editMode = false) {
  const quickPopRow = document.querySelector('.player-panel .quick-populate-row');
  if (!quickPopRow) return;
  quickPopRow.innerHTML = ''; 
  const names = getQuickNames(); // Now a simple array of strings

  const currentPlayers = [...list.children].map(item => item.querySelector('.player-name').value.trim().toLowerCase());

  names.forEach(name => {
    const btnContainer = document.createElement('div');
    btnContainer.className = 'quick-pop-btn-container';

    const button = document.createElement('button');
    button.textContent = name;
    button.className = 'quick-pop-btn';
    if (currentPlayers.includes(name.toLowerCase())) {
      button.classList.add('used');
      button.disabled = true;
    }
    button.addEventListener('click', () => {
      const emptyPlayerSlot = [...list.children].find(item => !item.querySelector('.player-name').value.trim());
      if (emptyPlayerSlot) {
        const nameInput = emptyPlayerSlot.querySelector('.player-name');
        nameInput.value = name;
        nameInput.dispatchEvent(new Event('input', { bubbles: true })); // Trigger input event to update states
        updateAllPlayerStates(); // Explicitly call to ensure state is updated for auto-roll
         if (emptyPlayerSlot.dataset.active === 'true') singleRoll(emptyPlayerSlot);
      } else if (list.children.length < MAX_PLAYERS) {
        addPlayer();
        const newPlayerItem = list.lastChild;
        const nameInput = newPlayerItem.querySelector('.player-name');
        nameInput.value = name;
        nameInput.dispatchEvent(new Event('input', { bubbles: true }));
        updateAllPlayerStates();
        if (newPlayerItem.dataset.active === 'true') singleRoll(newPlayerItem);
      }
      updateQuickPopButtons(); // Re-render to update 'used' state
    });
    btnContainer.appendChild(button);

    if (editMode) {
      const removeIcon = document.createElement('span');
      removeIcon.className = 'remove-name-icon';
      removeIcon.innerHTML = '<i class="fas fa-xmark"></i>'; // Use Font Awesome icon
      removeIcon.title = 'Remove this name permanently';
      removeIcon.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent button click
        const nameToRemove = name;
        let storedNames = getQuickNames();
        storedNames = storedNames.filter(n => n !== nameToRemove);
        saveQuickNames(storedNames);

        // Also remove from LAST_ROLL_ALL_TEAM_KEY if present
        let lastTeam = JSON.parse(localStorage.getItem(LAST_ROLL_ALL_TEAM_KEY) || '[]');
        lastTeam = lastTeam.filter(n => n !== nameToRemove);
        localStorage.setItem(LAST_ROLL_ALL_TEAM_KEY, JSON.stringify(lastTeam));

        renderQuickPopulateButtons(true); // Re-render in edit mode
      });
      btnContainer.appendChild(removeIcon);
    }
    quickPopRow.appendChild(btnContainer);
  });
  updateQuickPopButtons(); // Update used state for all buttons
}

// Function to update the state of quick populate buttons
function updateQuickPopButtons() {
  const playerNames = [...list.querySelectorAll('input.player-name')].map(input => input.value.trim()).filter(name => name !== '');
  const quickPopButtons = document.querySelectorAll('.player-panel .quick-pop-btn'); // Ensure targeting within player-panel

  quickPopButtons.forEach(button => {
    const name = button.textContent;
    if (playerNames.includes(name)) {
      button.classList.add('used');
      button.disabled = true; 
    } else {
      button.classList.remove('used');
      button.disabled = false; 
    }
  });
}

// New function to update active states and auto-add player
function updateAllPlayerStates() {
  const players = [...list.children];
  let allActive = true;
  let activePlayerCount = 0;

  players.forEach(li => {
    const nameInput = li.querySelector('.player-name');
    const rollButton = li.querySelector('.roll');
    if (nameInput.value.trim() !== '') {
      li.dataset.active = 'true';
      rollButton.disabled = false;
      rollButton.classList.remove('disabled');
      activePlayerCount++;
    } else {
      li.dataset.active = 'false';
      rollButton.disabled = true;
      rollButton.classList.add('disabled');
      allActive = false; // If any is empty, not all are active
    }
  });

  // Auto-add new player if all existing have names and we are below max players
  if (allActive && players.length > 0 && players.length < MAX_PLAYERS) {
    addPlayer();
  }
  updateUI();
  updateDiceDots(); // Update dice dots after potential auto-add
}

// Update dice dots whenever the list children change (add/remove/sort)
const observer = new MutationObserver(updateDiceDots);
observer.observe(list, { childList: true });
</script>
<div class="quick-populate-row">
</div>
</body>
</html>
